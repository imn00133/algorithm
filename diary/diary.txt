# 20.01.19.
현재 모듈 단위 convention은 숫자_문제 이름으로 사용하고 있다.
다만, debugging을 위해 import를 하면 오류가 난다(invalid token)
이를 검색해보니, 식별자는 숫자로 시작할 수 없다...
https://rfriend.tistory.com/305
이렇게 간단한 거에서 버그를 내다니.
절 별로 폴더를 나누기는 약간 많고, interpreter에서 불러와서 해결하는 걸 포기해야겠다.

_(underscore)에서 오류나는 줄 알고 겸사겸사 underscore도 찾아보았다.
https://mingrammer.com/underscore-in-python/

레오폴드 저소음 적축을 샀는데, 키압이 너무 낮은 것 같다.
자꾸 오타가 나는게 원... 적응되면 나아지지 않을까 싶다.
왼쪽 팔목이 아픈데, 이건 팜레스트를 사고 운동도 해야되지 않을까 싶다.
왼쪽 팔목을 일직선으로 두게 되면 좀 괜찮은데 흐음.
오른쪽 팔목도 그런 느낌이 있는게, 주의해야 될 것 같다.

# 20.01.30.
만들다 만 카라츠바 곱셈을 마져 작성했다.
다만, 책에서 구현안된 부분 쪽 문제가 꽤 있어서 많은 오류를 수정하였다.
몇 가지 테스트를 했을 때, 문제가 없는 것을 보아. 아마 버그가 없을 듯 한데...
꼭 새로운 변수를 만들지 않는 것도 좋은 것 같다.

tistory 블로그를 시작하였다. https://bk-worm.tistory.com
다만, 글쓰는게 힘들 뿐. 첫 글을 뭘 쓸지 모르겠다.
python 강의자료도 올리고 해야되는데.

모니터를 보고 있으니 눈이 아프다.
캘리브레이션까지 했는데 흰색을 보고 있으면 눈이 피로하다.
조명문제인지 아닌지 모르겠구만. 결국 모니터를 하나 더 사긴 했는데.. 흐음.

# 20.03.19.
간만에 접속하여 문제 풀이를 남겼다.
전역한 이후로 정신건강도 안 좋았고, 공부를 하고 싶지 않았기 때문이다.
좀 정신차리고 움직이고 있는데, 공부가 잘 안된다.
디지털로 글을 읽으면 건너뛰어서 읽고, 오프라인도 잘 읽지 못하고 있다.

글 쓸 것도 많은데, 언제 쓸지 모르겠다. 어휴
Algorithm 관련해서도 글을 조금씩 써야 될 것 같은데...
오늘 공부했던 부분에 대해서도 글을 써야겠다.

# 20.03.20.
10828문제에서 문제가 조금 있었다. 2-3시간 소비했는데... 단순한 버그였다.

오늘 공부하면서 알게 된 점은 다음과 같다.
super()는 암묵적으로 self를 주기 때문에, self를 전달하지 않아도 self에 자동 사용이 된다.
시간 초과가 날 경우에는 import sys, sys.std.readline을 사용하면 된다.
input을 대체해서 사용해도 된다. 단, strip으로 뒤에 붙은 '\n'을 삭제해야 한다.
stack은 list의 잦은 사용으로 느린 듯하다. pythonic한 방법이 더 빠르다.
단어를[::-1]로 하면, 역순으로 출력이 가능하다.

C++도 공부하긴 해야되는데 귀찮다.
영어 공부도 해야되는데 다 놓고... 컴퓨터 공부만 하고 있다.

# 20.03.21.
1874번 문제에서 거의 비슷한 방법인데, 다른 사람보다 속도가 매우 느렸다.
빠른 사람들을 천천히 살펴보니, string연산이 아니라 리스트로 op_string을 처리하는 것을 보았다.
string의 덧셈을 리스트로 변경하니, 속도가 8배 빨라졌다.
string연산이 매우 느리니 주의해야겠다.

# 20.03.24.
2일정도 쉬다가 간만에 문제를 풀었다. 쇠막대기(10799)까지는 풀만 했는데, 오큰수는 brute force밖에 생각이 나지 않는다.
내일까지 고민해보고, 강의를 들어야겠다.

# 20.03.25.
단어뒤집기2 17413문제는 flag를 사용하지 않고 해결하려고 했는데, flag를 사용하는 것도 나쁘지 않을 것 같다.
좀 더 복잡해지긴 했지만, 크게 문제는 없으니 넘겨도 될 것 같다.
쇠막대기(10799)문제의 해결 방법을 보니, flag를 사용하지 않고 index를 통해 레이저인지 아닌지 판단하는 방법이 있었다.
방법은 거의 같고 채점된 실행속도는 같았지만, 읽기가 더 좋았다.
오큰수(17298)는 스택을 사용해서 문제를 해결할 수 있다는 점이 신기했다.
스택을 통해 큰 수를 내림차순으로 정리할 수 있다는 점은 고려하지 못했던 것 같다.
앞으로 문제를 계속 풀다보면 보이지 않을까 싶다.

오등큰수(17299)는 갑자기 runtime error가 떠서 당황했는데, 1,000,000을 넣기 위해서는 배열이 1이 더 커야 되었다.
항상 맨 첫 값과 끝 값은 주의해야 한다.

자료구조 1의 203 pdf가 있는데, 이에 대한 영상이 없는 것을 보아 직접 공부해서 풀어야 겠다.
영상을 보면서 추가적으로 풀어야 될 것 같다.

지금은 함수를 통해 약간씩 묶어주고 있는데, 코드의 양을 줄이는 것이 좋을지, 쉽게 읽는게 좋을지 모르겠다.
함수를 만들면, 각 흐름이 분해되어서 읽기가 편해지만, 작성속도가 느려지는 문제가 있긴 하다.

# 20.03.26.
간만에 재귀함수를 만들었더니 오류가 많았다.
원하는 대로 돌아가는데, 값이 자꾸 None이 되어서 꽤 고민하였다.
원인은 재귀를 할 때 return으로 값을 반환하지 않아서 그랬다. 에휴.

sovled.ac에 있는 class를 조금씩 높여보기로 했다. class1은 너무 쉬운게 아닌가 싶지만. 일단 풀어야겠다.
사실 쉽다고 느끼는 이유가 python에서 자동으로 해주는 것들을 사용해서 그런거지 다른 언어로 풀려고 하면 작성할 것이 많다.

# 20.03.27.
연산자 등 계산할 때 우선순위가 필요한 경우가 생겼다.
이 때는 priority함수를 만들어서 우선순위를 반환하도록 한 뒤, 이를 통해 비교하는게 편하다는 것을 배웠다.
모든 경우의 수 따지느라 머리 아팠는데 으아.

# 20.03.28.
아스키코드 문제를 풀이하면서 알파벳 리스트를 만드는 경우가 많았다.
그런데, 꼭 마지막을 까먹는 경우가 많은 것 같다.
range는 마지막이 포함되지 않는다는 점과 개수를 샐 때는 +1를 해준다는 점을 잘 기억해야겠다.

EOF문제가 간만에 나왔다. 이를 처리하는데 골치를 많이 썩혔다.
input에 대한 try, except를 사용한 방법은 codeplus 100StartAlgorithm의 10951을 참고한다.
sys.stdin.readline에 대해 빈 문자열로 EOF를 처리하는 방법은 codeplus 200DataStructure의 10820을 참고한다.
sys.stdin은 파일과 유사하기 때문에 EOF를 받으면, 빈 문자열을 출력하는 것으로 보인다.

C나 C++의 strlen 함수의 시간 복잡도는 O(N)이라고 한다.
이것 때문에 반복문을 조심해서 사용하라고 한다.
그런데, python의 len(list)의 시간복잡도는 O(1)이라고 한다.
https://wayhome25.github.io/python/2017/06/14/time-complexity/ 를 참고한다.

range(start, end, -1)을 통해 class1의 2742번 문제를 풀었다.
반대로 내려갈 수 없으면 어떻게 풀지라는 생각이 없었는데, 다른 사람을 보니 end - index로 해결하였다.
너무 파이썬에 익숙해지는게 아닌가 싶다.

카카오 2019 겨울 인턴십 문제를 풀어보았다.
공부를 안한 것 치고는 많이 풀었는데, 효율성 문제가 어려운 것 같다.
좀 더 공부하면 다 풀 수 있지 않을까 싶다.
생각보다 많이 풀어서 재미있었다.
1번 문제는 쉬웠으나, 2번 문제는 O(n^3)으로 풀었고, 3번 문제는 거의 접근하였으나 중복을 해결하지 못하였다.
4번은 그냥 푸는건 어렵지 않았는데, 효율성문제는 풀지 못했다.
하긴, 아직 스택/큐만 배웠으니... 좀 더 가면 잘 풀 수 있지 않을까?

# 20.03.29.
밤에 잠에 안 와서 문제를 풀고 있다.
PS가 재미있긴 한데, 이렇게 밤새 풀고 있는 걸 보니 미친 것 같다.

6588문제를 풀면서 느낀 점이 많다.
print를 사용했을 때는 4200ms가 나오다가 sys.stdin.readline을 사용하니 280ms로 감소하였다.
입력이 많을 때는 꼭 sys.stdin을 사용하자.
다른 사람의 풀이를 보다가 깨달은 점이 있는데,
range(start, end, step)을 제대로 사용하지 못하고 있었다.
start값이 초기값이니, 제곱으로 시작하고, step을 더해나가는 값으로 생각해서 만들면 range로도 쉽게 가능하다.
이게 생각나지 않아서 while로 억지로 쓰다니...
마지막으로, 최대 상수는 상수를 만들어서 쓰자.
상수는 오타내면, 찾기가 어렵다. 또한 magic number는 사용하지 않는게 좋은데, 아무생각없이 썼다.

처음에 2를 제거하려고 각종 조건을 다 붙였었다. 다른 사람것을 보니 생각하지 않고 풀었었다.
생각해보니 짝수임으로 2는 처음에 확인만할 뿐, 절대로 추가될 리가 없는 값이였다.
그 잠깐의 계산을 제거하기 위해서 각종 조건을 붙이는 것 보다는 그냥 넣는게 훨씬 깔끔했다.
또한, 예외처리를 미리하기 보다는 prime에서 2만 제거하는게 훨씬 간단했을 것 같다.

아직까지 에라토스테네스의 체를 만드는 것이 어려운 것 같다. 시간이 좀 걸린다.
다만, 이렇게 만든다를 생각하면 쉽게 만들 수 있지 않을까 싶다.

9613번 문제는 간만에 재귀로 풀었다. 재귀가 어떨때는 쉽긴 한데, 오류가 나면 해결하기가 너무 어렵다.

17087번 문제를 재귀로 풀려고 하였으나, N= 10^5여서 런타임 오류로 폭파되었다.
연습 좀 하려고 했더니...

1373번
진수를 변환하는 여러가지 방법이 있다.
bin, oct, hex, int(접두어 값, 진수), format(숫자, 다른진수)
https://www.daleseo.com/python-int-bases/를 참고한다.

n진법 숫자를 10진법 숫자로 변환하는 방법은
https://programmers.co.kr/learn/courses/4008/lessons/12733 를 참고한다.

string을 hex진수로 변환하기 위해서는 encode를 사용한다.
https://doriri.tistory.com/3

2089번
-2진수를 계산하는 방법이 매우 어려웠다.
진수 변환과 같은 방법으로 하면 된다고 하였지만, 아무리해도 답이 나오지 않았다.
이 문제만 1시간 넘게 풀려고 했던 것 같은데, 결국에는 이해하였다.
-2로 나눴을 때, 나머지가 1이나 0이 되도록 조정하는것이 목표였다.
이해하고 나니 편하다.

17103번
check_prime을 True로 만들어두니, 리스트 내포를 사용하기 쉬었다.
이를 풀면서 6588의 문제점을 알아냈는데, 2루트 만큼의 수만 prime에 들어가 있다.
이렇게 구현했는데도 풀린 것을 보면 낮은 값에서 답이 나오는 것을 알 수 있다.
test해보니 1,000,000이하에서는 1000이하의 소수로 골드바흐의 문제가 풀리는 것을 볼 수 있었다.
일단 해결됨으로 수정하지 않고 놔둔다.

20.03.30.
dynamic programming을 시작하였다. 점화식을 잘 세울수 있을지 모르겠다.
가능하다면 Bottom up/top down을 둘 다 구현해보는 것을 목표로 해야겠다.
재귀 최대 깊이 지정은 https://algoshipda.blogspot.com/2015/05/syssetrecursionlimit-limit.html을 참고한다.

1463번
재귀 최대 깊이를 변경하여도, stack size의 제한이 있어 해결할 수 없다.
(exit code 0xc0000fd 오류 발생)
https://bugs.python.org/issue32570
이는 윈도우의 스택은 2MB, 리눅스는 8MB를 잡기 때문이다.
이를 해결하는 방법중 하나는 tread를 사용하는 방법
https://stackoverflow.com/questions/2067637/how-do-i-increase-the-stack-size-in-python
이 있으나, 해결되지 않았다.
어쩌피 dp_arr에 저장됨으로, 1000으로 값을 나눠 계산하고, 깊이 및 stack 사용량을 줄였다.
bottom_up은 전혀 문제가 없다.

dp_arr의 0과 1은 초기값을 넣어주었음으로, bottom up에서 2부터 시작해야 한다.
처음에 0으로 초기화해서 문제가 없었지. 아니였으면 오류가 있을 뻔 했다.

# 20.03.31.
11052 문제는 top_down을 다시보니 문제가 발생할만한 곳이 있었다.
for에서 top_down을 호출하는게 0이 되는지점이 존재하였다.
그런데, dp_arr[num]을 0으로 초기화해서 문제없이 해결되었던 점이 있다.

16194 문제가 매우 어려웠다.
생각하는대로 재귀를 하려고 하였으나, 재귀는 계속 값이 나오지 않아 일단 넘겼다.
그리고 https://takeknowledge.tistory.com/104을 보고 해결하였다.
bottom up도 하다하다 안되서 답지를 보았다.
index부분과 초기화부분이 문제였다 하아..
항상 맨 처음과 마지막을 잘 보는 연습을 해야될 것 같다.
특히 0부터 시작할지, 1부터 시작할지와, num-index가 0을 참조하는지도 고려해야 한다.

이 문제에서는 min함수를 사용할 수 없었고, -1일 때를 고려해야 했다.
dp 구현 연습이 많이 필요하다.

15990문제를 몇 시간 잡아먹었는지 모르겠다.
다른 차이가 없는데 대체 왜 시간초과가 이렇게 나는지 고민했는데,
숫자가 들어올 때마다, dp를 재계산해서 그랬다.
그래서 continue로 넘겨보려고 했지만, 이걸로는 역부족이였는지 계산을 완료하지 못했다.
lazy evaluation(계으른 계산)이 훨씬 빠를 것 같았으나, continue로는 처리하지 못했다.
아무래도 계산이 완료된 최대 값을 저장하고, 그 이하는 계산하지 않는 등의 방법이 필요한가보다.

bottom_up으로 해결할 때는 그냥 미리 계산을 끝까지 해놓고 보는게 좋다고 생각된다.

재귀함수는 http://blog.naver.com/mirusu400/221788252855의 도움을 받아 처리하였다.
재귀함수를 나눠서 써야 되었다.
재귀함수를 나눠서 계산하는 방법은 1463번을 참고한다.
재귀함수에서 정답이 아니여서 비교하였는데, 마지막 num-2의 2와 num-1의 1을 호출하지 않았다.
그래서 따로 예외처리를 해주었다.
이 문제는 재귀함수가 더 어려운 듯 하다.

앞에서 정말 어렵게 풀었더니, 뒤로 갈수록 쉽게 문제를 푸는 것 같다.
에휴 힘들다.

# 20.04.01.
11005번
출력하는 방법이 여러가지가 있는데, 자꾸 한가지만 쓴다.
''.join(reversed(리스트))
for을 사용해서 거꾸로 출력하는 방법
거의 비슷할 것 같긴 한데..

11053번
dp_arr을 1로 초기화하면(무조건 1번은 자기자신임으로) 편하다.
하지만, 재귀로 계산할 때는 계산을 했는지 하지 않았는지 알기 어려움으로 0으로 계산하였다.

이를 재귀로 바뀌는 것이 매우 어려웠는데, sequence를 조각내어 작게 만들다가 계산이 엉망이 되었다.
다시 생각해보니 index만 줄여가면서 보내도 문제가 없다는 결론을 내려 인덱스만 내리도록 했다.
그리고도 계산이 제대로 되지 않아, 일단 넘기기로 했다.

스트레스 받아서 엄청나게 쉬다가, 다시 재귀를 보았다.
일반적인 dp와는 다르게, 이 문제는 다시 한 번 읽어야 되는 문제이다.
그러다 보니 재귀를 해도 줄어든다는 느낌이 별로 없는 것 같다.
재귀를 작성하였으나, 틀리는 것을 보아 알고리즘에 문제가 있는 모양이다.
포기 나중에 생각하자

14002번
11053번도 재귀를 해결하지 못했기 때문에 포기했다.
LIS를 찾기 위해서 재귀를 사용하였는데, 처음에는 lis라는 리스트 변수를 만들었다.
append로 재귀에서 받아와서 마지막에 출력하도록 했는데, 강의 자료를 보니 더 좋은 방법이 있었다.
어쩌피 맨 처음까지 돌아가기 때문에 return에서 출력하면 되는 거였다.
복잡하게 받아와서 출력하지 않으니 더 편하다.

# 20.04.02.
1912번
재귀를 작성했는데 하도 오류가 나서 test코드를 작성하여 점검하였다.
문제가 되었던 부분은, stack이 터지는 것을 막기 위해 1000마다 나누는 부분이 문제였다.
이미 계산된 dp_arr를 재계산하지 않고 return 하는 로직이 없었고,
이 부분을 추가하면서 sequence와 dp_arr의 길이 비교를 했었던 문제가 있었다.
좀 더 함수를 잘개 쪼개면, 더 test하기가 더 편했겠지만, 알고리즘에서 그렇게까지 하긴 힘든 것 같다.
재사용성의 중요성을 test코드 작성하면서 계속 느낀다.

1699번
시간초과가 계속해서 나서 왜 나는지 알 수 없었는데, pypy3로 제출한 이후에 다른 사람의 답을 보니 알 수 있었다.
bottom up에서 제곱을 각각 계산하게 되어 있었는데, 파이썬의 이 부분이 매우 느린 것으로 보인다.
따라서 square변수를 두고, 값을 저장하여 1번만 계산하도록 두었다.
다른 사람들의 글에서는 오래 걸리는 sqaure를 맨 처음에 계산하여 꺼내쓸 수 있도록 해놓았다.

재귀함수는 앞과 같은 방식이라 작성에 실패하였다.
전체를 다시 반복할 때, 문제없이 반복하려면 어떻게 해야할까 흐음..
index를 주는 방법도 있을 것 같은데.

leet SingleNumber
set을 보통 사용하지 않다보니, 너무 오래 걸리는 코드를 작성하였는데, in을 사용할 수 있었다.
답지를 볼 수 있었는데, 수학적인 것 까지는 이해할 수 있었으나, bit연산은 생각지도 못했다
정말 놀랍다.

2225번
3 중첩 재귀함수는 도저히 못하겠다. 포기한다.
3중첩으로 DP를 풀었는데, 빠른 것이 있어서 읽어보았다.
O(n^2)으로 풀었는데, 이게 어떻게 작동하는지 모르겠다.
https://www.acmicpc.net/source/18848782
https://do-rang.tistory.com/7 를 참고한다.

stack limit size 해결하기 - 1463번 stack_test확인 사용
thread로 하면 그래도 어느정도 해결이 된다.
일반 top_down으로 하면 3000정도에서 막히지만,
thread로 하면 409000정도까지 계산한 후에 멈춘다.
이 멈추는 상황이 나타나지 않아서 명확하지 않았지만, stack_size를 조절하니 늘어나는 것을 볼 수 있었다.
다만, 이 스택 사이즈도 한계가 있어서 재귀를 쓰기 좋지 않긴하다.
관련해서 쓸 사이트다
thread
http://pythonstudy.xyz/python/article/24-%EC%93%B0%EB%A0%88%EB%93%9C-Thread
https://soooprmx.com/archives/8834
C stack 한계
https://stackoverflow.com/questions/19406800/what-is-the-ideal-stack-size-for-a-thread-in-python-that-connects-to-a-socket
https://bugs.python.org/issue32570
https://www.reddit.com/r/learnpython/comments/52xewh/need_help_with_0xc00000fd/
thread로 일단 해결보기
https://stackoverflow.com/questions/20629027/process-finished-with-exit-code-1073741571
unix에서만 가능
ulimit로 스택 한도 변경도 가능
http://faq.hostway.co.kr/Linux_ETC/7179
python의 resource로 변경 가능
https://stackoverflow.com/questions/5061582/setting-stacksize-in-a-python-script
https://docs.python.org/ko/3/library/resource.html
stackless python
https://namu.wiki/w/Python#s-4.1

# 20.04.03.
day2 happy number
너무 dp연습만 했나보다. 정말 pythonic한 방법이 있었는데, 그냥 arr에 때려넣고 풀었다.
집합을 잘 사용하지 않았는데, 집합을 사용해보니 중복제거에는 매우 편하다. 사용하는 연습을 해야겠다.

day3 maximum subarray
이전에 배웠던 거라 dp로 풀었는데, 분할탐색으로도 풀 수 있다고 한다.
알고리즘 공부하다보면 나오겠지..?


@@@
20.04.01
11053 재귀 함수 작성
14002 재귀 함수 작성

20.04.02
1699 재귀 함수 작성 - 11053 및 14002와 for문으로 전체를 순환해야하여, 작성 불가
# index를 넘겨주면 어떨까?
2225 3중첩 재귀...? # O(N^2)?