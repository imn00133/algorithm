# 20.01.19.
현재 모듈 단위 convention은 숫자_문제 이름으로 사용하고 있다.
다만, debugging을 위해 import를 하면 오류가 난다(invalid token)
이를 검색해보니, 식별자는 숫자로 시작할 수 없다...
https://rfriend.tistory.com/305
이렇게 간단한 거에서 버그를 내다니.
절 별로 폴더를 나누기는 약간 많고, interpreter에서 불러와서 해결하는 걸 포기해야겠다.

_(underscore)에서 오류나는 줄 알고 겸사겸사 underscore도 찾아보았다.
https://mingrammer.com/underscore-in-python/

레오폴드 저소음 적축을 샀는데, 키압이 너무 낮은 것 같다.
자꾸 오타가 나는게 원... 적응되면 나아지지 않을까 싶다.
왼쪽 팔목이 아픈데, 이건 팜레스트를 사고 운동도 해야되지 않을까 싶다.
왼쪽 팔목을 일직선으로 두게 되면 좀 괜찮은데 흐음.
오른쪽 팔목도 그런 느낌이 있는게, 주의해야 될 것 같다.

# 20.01.30.
만들다 만 카라츠바 곱셈을 마져 작성했다.
다만, 책에서 구현안된 부분 쪽 문제가 꽤 있어서 많은 오류를 수정하였다.
몇 가지 테스트를 했을 때, 문제가 없는 것을 보아. 아마 버그가 없을 듯 한데...
꼭 새로운 변수를 만들지 않는 것도 좋은 것 같다.

tistory 블로그를 시작하였다. https://bk-worm.tistory.com
다만, 글쓰는게 힘들 뿐. 첫 글을 뭘 쓸지 모르겠다.
python 강의자료도 올리고 해야되는데.

모니터를 보고 있으니 눈이 아프다.
캘리브레이션까지 했는데 흰색을 보고 있으면 눈이 피로하다.
조명문제인지 아닌지 모르겠구만. 결국 모니터를 하나 더 사긴 했는데.. 흐음.

# 20.03.19.
간만에 접속하여 문제 풀이를 남겼다.
전역한 이후로 정신건강도 안 좋았고, 공부를 하고 싶지 않았기 때문이다.
좀 정신차리고 움직이고 있는데, 공부가 잘 안된다.
디지털로 글을 읽으면 건너뛰어서 읽고, 오프라인도 잘 읽지 못하고 있다.

글 쓸 것도 많은데, 언제 쓸지 모르겠다. 어휴
Algorithm 관련해서도 글을 조금씩 써야 될 것 같은데...
오늘 공부했던 부분에 대해서도 글을 써야겠다.

# 20.03.20.
10828문제에서 문제가 조금 있었다. 2-3시간 소비했는데... 단순한 버그였다.

오늘 공부하면서 알게 된 점은 다음과 같다.
super()는 암묵적으로 self를 주기 때문에, self를 전달하지 않아도 self에 자동 사용이 된다.
시간 초과가 날 경우에는 import sys, sys.std.readline을 사용하면 된다.
input을 대체해서 사용해도 된다. 단, strip으로 뒤에 붙은 '\n'을 삭제해야 한다.
stack은 list의 잦은 사용으로 느린 듯하다. pythonic한 방법이 더 빠르다.
단어를[::-1]로 하면, 역순으로 출력이 가능하다.

C++도 공부하긴 해야되는데 귀찮다.
영어 공부도 해야되는데 다 놓고... 컴퓨터 공부만 하고 있다.

# 20.03.21.
1874번 문제에서 거의 비슷한 방법인데, 다른 사람보다 속도가 매우 느렸다.
빠른 사람들을 천천히 살펴보니, string연산이 아니라 리스트로 op_string을 처리하는 것을 보았다.
string의 덧셈을 리스트로 변경하니, 속도가 8배 빨라졌다.
string연산이 매우 느리니 주의해야겠다.

# 20.03.24.
2일정도 쉬다가 간만에 문제를 풀었다. 쇠막대기(10799)까지는 풀만 했는데, 오큰수는 brute force밖에 생각이 나지 않는다.
내일까지 고민해보고, 강의를 들어야겠다.

# 20.03.25.
단어뒤집기2 17413문제는 flag를 사용하지 않고 해결하려고 했는데, flag를 사용하는 것도 나쁘지 않을 것 같다.
좀 더 복잡해지긴 했지만, 크게 문제는 없으니 넘겨도 될 것 같다.
쇠막대기(10799)문제의 해결 방법을 보니, flag를 사용하지 않고 index를 통해 레이저인지 아닌지 판단하는 방법이 있었다.
방법은 거의 같고 채점된 실행속도는 같았지만, 읽기가 더 좋았다.
오큰수(17298)는 스택을 사용해서 문제를 해결할 수 있다는 점이 신기했다.
스택을 통해 큰 수를 내림차순으로 정리할 수 있다는 점은 고려하지 못했던 것 같다.
앞으로 문제를 계속 풀다보면 보이지 않을까 싶다.

오등큰수(17299)는 갑자기 runtime error가 떠서 당황했는데, 1,000,000을 넣기 위해서는 배열이 1이 더 커야 되었다.
항상 맨 첫 값과 끝 값은 주의해야 한다.

자료구조 1의 203 pdf가 있는데, 이에 대한 영상이 없는 것을 보아 직접 공부해서 풀어야 겠다.
영상을 보면서 추가적으로 풀어야 될 것 같다.

지금은 함수를 통해 약간씩 묶어주고 있는데, 코드의 양을 줄이는 것이 좋을지, 쉽게 읽는게 좋을지 모르겠다.
함수를 만들면, 각 흐름이 분해되어서 읽기가 편해지만, 작성속도가 느려지는 문제가 있긴 하다.

# 20.03.26.
간만에 재귀함수를 만들었더니 오류가 많았다.
원하는 대로 돌아가는데, 값이 자꾸 None이 되어서 꽤 고민하였다.
원인은 재귀를 할 때 return으로 값을 반환하지 않아서 그랬다. 에휴.

sovled.ac에 있는 class를 조금씩 높여보기로 했다. class1은 너무 쉬운게 아닌가 싶지만. 일단 풀어야겠다.
사실 쉽다고 느끼는 이유가 python에서 자동으로 해주는 것들을 사용해서 그런거지 다른 언어로 풀려고 하면 작성할 것이 많다.

# 20.03.27.
연산자 등 계산할 때 우선순위가 필요한 경우가 생겼다.
이 때는 priority함수를 만들어서 우선순위를 반환하도록 한 뒤, 이를 통해 비교하는게 편하다는 것을 배웠다.
모든 경우의 수 따지느라 머리 아팠는데 으아.

# 20.03.28.
아스키코드 문제를 풀이하면서 알파벳 리스트를 만드는 경우가 많았다.
그런데, 꼭 마지막을 까먹는 경우가 많은 것 같다.
range는 마지막이 포함되지 않는다는 점과 개수를 샐 때는 +1를 해준다는 점을 잘 기억해야겠다.

EOF문제가 간만에 나왔다. 이를 처리하는데 골치를 많이 썩혔다.
input에 대한 try, except를 사용한 방법은 codeplus 100StartAlgorithm의 10951을 참고한다.
sys.stdin.readline에 대해 빈 문자열로 EOF를 처리하는 방법은 codeplus 200DataStructure의 10820을 참고한다.
sys.stdin은 파일과 유사하기 때문에 EOF를 받으면, 빈 문자열을 출력하는 것으로 보인다.

C나 C++의 strlen 함수의 시간 복잡도는 O(N)이라고 한다.
이것 때문에 반복문을 조심해서 사용하라고 한다.
그런데, python의 len(list)의 시간복잡도는 O(1)이라고 한다.
https://wayhome25.github.io/python/2017/06/14/time-complexity/ 를 참고한다.

range(start, end, -1)을 통해 class1의 2742번 문제를 풀었다.
반대로 내려갈 수 없으면 어떻게 풀지라는 생각이 없었는데, 다른 사람을 보니 end - index로 해결하였다.
너무 파이썬에 익숙해지는게 아닌가 싶다.

카카오 2019 겨울 인턴십 문제를 풀어보았다.
공부를 안한 것 치고는 많이 풀었는데, 효율성 문제가 어려운 것 같다.
좀 더 공부하면 다 풀 수 있지 않을까 싶다.
생각보다 많이 풀어서 재미있었다.
1번 문제는 쉬웠으나, 2번 문제는 O(n^3)으로 풀었고, 3번 문제는 거의 접근하였으나 중복을 해결하지 못하였다.
4번은 그냥 푸는건 어렵지 않았는데, 효율성문제는 풀지 못했다.
하긴, 아직 스택/큐만 배웠으니... 좀 더 가면 잘 풀 수 있지 않을까?

# 20.03.29.
밤에 잠에 안 와서 문제를 풀고 있다.
PS가 재미있긴 한데, 이렇게 밤새 풀고 있는 걸 보니 미친 것 같다.

6588문제를 풀면서 느낀 점이 많다.
print를 사용했을 때는 4200ms가 나오다가 sys.stdin.readline을 사용하니 280ms로 감소하였다.
입력이 많을 때는 꼭 sys.stdin을 사용하자.
다른 사람의 풀이를 보다가 깨달은 점이 있는데,
range(start, end, step)을 제대로 사용하지 못하고 있었다.
start값이 초기값이니, 제곱으로 시작하고, step을 더해나가는 값으로 생각해서 만들면 range로도 쉽게 가능하다.
이게 생각나지 않아서 while로 억지로 쓰다니...
마지막으로, 최대 상수는 상수를 만들어서 쓰자.
상수는 오타내면, 찾기가 어렵다. 또한 magic number는 사용하지 않는게 좋은데, 아무생각없이 썼다.

처음에 2를 제거하려고 각종 조건을 다 붙였었다. 다른 사람것을 보니 생각하지 않고 풀었었다.
생각해보니 짝수임으로 2는 처음에 확인만할 뿐, 절대로 추가될 리가 없는 값이였다.
그 잠깐의 계산을 제거하기 위해서 각종 조건을 붙이는 것 보다는 그냥 넣는게 훨씬 깔끔했다.
또한, 예외처리를 미리하기 보다는 prime에서 2만 제거하는게 훨씬 간단했을 것 같다.

아직까지 에라토스테네스의 체를 만드는 것이 어려운 것 같다. 시간이 좀 걸린다.
다만, 이렇게 만든다를 생각하면 쉽게 만들 수 있지 않을까 싶다.

9613번 문제는 간만에 재귀로 풀었다. 재귀가 어떨때는 쉽긴 한데, 오류가 나면 해결하기가 너무 어렵다.

17087번 문제를 재귀로 풀려고 하였으나, N= 10^5여서 런타임 오류로 폭파되었다.
연습 좀 하려고 했더니...

1373번
진수를 변환하는 여러가지 방법이 있다.
bin, oct, hex, int(접두어 값, 진수), format(숫자, 다른진수)
https://www.daleseo.com/python-int-bases/를 참고한다.

n진법 숫자를 10진법 숫자로 변환하는 방법은
https://programmers.co.kr/learn/courses/4008/lessons/12733 를 참고한다.

string을 hex진수로 변환하기 위해서는 encode를 사용한다.
https://doriri.tistory.com/3

2089번
-2진수를 계산하는 방법이 매우 어려웠다.
진수 변환과 같은 방법으로 하면 된다고 하였지만, 아무리해도 답이 나오지 않았다.
이 문제만 1시간 넘게 풀려고 했던 것 같은데, 결국에는 이해하였다.
-2로 나눴을 때, 나머지가 1이나 0이 되도록 조정하는것이 목표였다.
이해하고 나니 편하다.

17103번
check_prime을 True로 만들어두니, 리스트 내포를 사용하기 쉬었다.
이를 풀면서 6588의 문제점을 알아냈는데, 2루트 만큼의 수만 prime에 들어가 있다.
이렇게 구현했는데도 풀린 것을 보면 낮은 값에서 답이 나오는 것을 알 수 있다.
test해보니 1,000,000이하에서는 1000이하의 소수로 골드바흐의 문제가 풀리는 것을 볼 수 있었다.
일단 해결됨으로 수정하지 않고 놔둔다.

20.03.30.
dynamic programming을 시작하였다. 점화식을 잘 세울수 있을지 모르겠다.
가능하다면 Bottom up/top down을 둘 다 구현해보는 것을 목표로 해야겠다.
재귀 최대 깊이 지정은 https://algoshipda.blogspot.com/2015/05/syssetrecursionlimit-limit.html을 참고한다.

1463번
재귀 최대 깊이를 변경하여도, stack size의 제한이 있어 해결할 수 없다.
(exit code 0xc0000fd 오류 발생)
https://bugs.python.org/issue32570
이는 윈도우의 스택은 2MB, 리눅스는 8MB를 잡기 때문이다.
이를 해결하는 방법중 하나는 tread를 사용하는 방법
https://stackoverflow.com/questions/2067637/how-do-i-increase-the-stack-size-in-python
이 있으나, 해결되지 않았다.
어쩌피 dp_arr에 저장됨으로, 1000으로 값을 나눠 계산하고, 깊이 및 stack 사용량을 줄였다.
bottom_up은 전혀 문제가 없다.

dp_arr의 0과 1은 초기값을 넣어주었음으로, bottom up에서 2부터 시작해야 한다.
처음에 0으로 초기화해서 문제가 없었지. 아니였으면 오류가 있을 뻔 했다.

