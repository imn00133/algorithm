# 20.01.19.
현재 모듈 단위 convention은 숫자_문제 이름으로 사용하고 있다.
다만, debugging을 위해 import를 하면 오류가 난다(invalid token)
이를 검색해보니, 식별자는 숫자로 시작할 수 없다...
https://rfriend.tistory.com/305
이렇게 간단한 거에서 버그를 내다니.
절 별로 폴더를 나누기는 약간 많고, interpreter에서 불러와서 해결하는 걸 포기해야겠다.

_(underscore)에서 오류나는 줄 알고 겸사겸사 underscore도 찾아보았다.
https://mingrammer.com/underscore-in-python/

레오폴드 저소음 적축을 샀는데, 키압이 너무 낮은 것 같다.
자꾸 오타가 나는게 원... 적응되면 나아지지 않을까 싶다.
왼쪽 팔목이 아픈데, 이건 팜레스트를 사고 운동도 해야되지 않을까 싶다.
왼쪽 팔목을 일직선으로 두게 되면 좀 괜찮은데 흐음.
오른쪽 팔목도 그런 느낌이 있는게, 주의해야 될 것 같다.

# 20.01.30.
만들다 만 카라츠바 곱셈을 마져 작성했다.
다만, 책에서 구현안된 부분 쪽 문제가 꽤 있어서 많은 오류를 수정하였다.
몇 가지 테스트를 했을 때, 문제가 없는 것을 보아. 아마 버그가 없을 듯 한데...
꼭 새로운 변수를 만들지 않는 것도 좋은 것 같다.

tistory 블로그를 시작하였다. https://bk-worm.tistory.com
다만, 글쓰는게 힘들 뿐. 첫 글을 뭘 쓸지 모르겠다.
python 강의자료도 올리고 해야되는데.

모니터를 보고 있으니 눈이 아프다.
캘리브레이션까지 했는데 흰색을 보고 있으면 눈이 피로하다.
조명문제인지 아닌지 모르겠구만. 결국 모니터를 하나 더 사긴 했는데.. 흐음.

# 20.03.19.
간만에 접속하여 문제 풀이를 남겼다.
전역한 이후로 정신건강도 안 좋았고, 공부를 하고 싶지 않았기 때문이다.
좀 정신차리고 움직이고 있는데, 공부가 잘 안된다.
디지털로 글을 읽으면 건너뛰어서 읽고, 오프라인도 잘 읽지 못하고 있다.

글 쓸 것도 많은데, 언제 쓸지 모르겠다. 어휴
Algorithm 관련해서도 글을 조금씩 써야 될 것 같은데...
오늘 공부했던 부분에 대해서도 글을 써야겠다.

# 20.03.20.
10828문제에서 문제가 조금 있었다. 2-3시간 소비했는데... 단순한 버그였다.

오늘 공부하면서 알게 된 점은 다음과 같다.
super()는 암묵적으로 self를 주기 때문에, self를 전달하지 않아도 self에 자동 사용이 된다.
시간 초과가 날 경우에는 import sys, sys.std.readline을 사용하면 된다.
input을 대체해서 사용해도 된다. 단, strip으로 뒤에 붙은 '\n'을 삭제해야 한다.
stack은 list의 잦은 사용으로 느린 듯하다. pythonic한 방법이 더 빠르다.
단어를[::-1]로 하면, 역순으로 출력이 가능하다.

C++도 공부하긴 해야되는데 귀찮다.
영어 공부도 해야되는데 다 놓고... 컴퓨터 공부만 하고 있다.

# 20.03.21.
1874번 문제에서 거의 비슷한 방법인데, 다른 사람보다 속도가 매우 느렸다.
빠른 사람들을 천천히 살펴보니, string연산이 아니라 리스트로 op_string을 처리하는 것을 보았다.
string의 덧셈을 리스트로 변경하니, 속도가 8배 빨라졌다.
string연산이 매우 느리니 주의해야겠다.

# 20.03.24.
2일정도 쉬다가 간만에 문제를 풀었다. 쇠막대기(10799)까지는 풀만 했는데, 오큰수는 brute force밖에 생각이 나지 않는다.
내일까지 고민해보고, 강의를 들어야겠다.

# 20.03.25.
단어뒤집기2 17413문제는 flag를 사용하지 않고 해결하려고 했는데, flag를 사용하는 것도 나쁘지 않을 것 같다.
좀 더 복잡해지긴 했지만, 크게 문제는 없으니 넘겨도 될 것 같다.
쇠막대기(10799)문제의 해결 방법을 보니, flag를 사용하지 않고 index를 통해 레이저인지 아닌지 판단하는 방법이 있었다.
방법은 거의 같고 채점된 실행속도는 같았지만, 읽기가 더 좋았다.
오큰수(17298)는 스택을 사용해서 문제를 해결할 수 있다는 점이 신기했다.
스택을 통해 큰 수를 내림차순으로 정리할 수 있다는 점은 고려하지 못했던 것 같다.
앞으로 문제를 계속 풀다보면 보이지 않을까 싶다.

오등큰수(17299)는 갑자기 runtime error가 떠서 당황했는데, 1,000,000을 넣기 위해서는 배열이 1이 더 커야 되었다.
항상 맨 첫 값과 끝 값은 주의해야 한다.

자료구조 1의 203 pdf가 있는데, 이에 대한 영상이 없는 것을 보아 직접 공부해서 풀어야 겠다.
영상을 보면서 추가적으로 풀어야 될 것 같다.

지금은 함수를 통해 약간씩 묶어주고 있는데, 코드의 양을 줄이는 것이 좋을지, 쉽게 읽는게 좋을지 모르겠다.
함수를 만들면, 각 흐름이 분해되어서 읽기가 편해지만, 작성속도가 느려지는 문제가 있긴 하다.

# 20.03.26.
간만에 재귀함수를 만들었더니 오류가 많았다.
원하는 대로 돌아가는데, 값이 자꾸 None이 되어서 꽤 고민하였다.
원인은 재귀를 할 때 return으로 값을 반환하지 않아서 그랬다. 에휴.

sovled.ac에 있는 class를 조금씩 높여보기로 했다. class1은 너무 쉬운게 아닌가 싶지만. 일단 풀어야겠다.
사실 쉽다고 느끼는 이유가 python에서 자동으로 해주는 것들을 사용해서 그런거지 다른 언어로 풀려고 하면 작성할 것이 많다.

# 20.03.27.
연산자 등 계산할 때 우선순위가 필요한 경우가 생겼다.
이 때는 priority함수를 만들어서 우선순위를 반환하도록 한 뒤, 이를 통해 비교하는게 편하다는 것을 배웠다.
모든 경우의 수 따지느라 머리 아팠는데 으아.

# 20.03.28.
아스키코드 문제를 풀이하면서 알파벳 리스트를 만드는 경우가 많았다.
그런데, 꼭 마지막을 까먹는 경우가 많은 것 같다.
range는 마지막이 포함되지 않는다는 점과 개수를 샐 때는 +1를 해준다는 점을 잘 기억해야겠다.

EOF문제가 간만에 나왔다. 이를 처리하는데 골치를 많이 썩혔다.
input에 대한 try, except를 사용한 방법은 codeplus 100StartAlgorithm의 10951을 참고한다.
sys.stdin.readline에 대해 빈 문자열로 EOF를 처리하는 방법은 codeplus 200DataStructure의 10820을 참고한다.
sys.stdin은 파일과 유사하기 때문에 EOF를 받으면, 빈 문자열을 출력하는 것으로 보인다.

C나 C++의 strlen 함수의 시간 복잡도는 O(N)이라고 한다.
이것 때문에 반복문을 조심해서 사용하라고 한다.
그런데, python의 len(list)의 시간복잡도는 O(1)이라고 한다.
https://wayhome25.github.io/python/2017/06/14/time-complexity/ 를 참고한다.

range(start, end, -1)을 통해 class1의 2742번 문제를 풀었다.
반대로 내려갈 수 없으면 어떻게 풀지라는 생각이 없었는데, 다른 사람을 보니 end - index로 해결하였다.
너무 파이썬에 익숙해지는게 아닌가 싶다.

카카오 2019 겨울 인턴십 문제를 풀어보았다.
공부를 안한 것 치고는 많이 풀었는데, 효율성 문제가 어려운 것 같다.
좀 더 공부하면 다 풀 수 있지 않을까 싶다.
생각보다 많이 풀어서 재미있었다.
1번 문제는 쉬웠으나, 2번 문제는 O(n^3)으로 풀었고, 3번 문제는 거의 접근하였으나 중복을 해결하지 못하였다.
4번은 그냥 푸는건 어렵지 않았는데, 효율성문제는 풀지 못했다.
하긴, 아직 스택/큐만 배웠으니... 좀 더 가면 잘 풀 수 있지 않을까?

# 20.03.29.
밤에 잠에 안 와서 문제를 풀고 있다.
PS가 재미있긴 한데, 이렇게 밤새 풀고 있는 걸 보니 미친 것 같다.

6588문제를 풀면서 느낀 점이 많다.
print를 사용했을 때는 4200ms가 나오다가 sys.stdin.readline을 사용하니 280ms로 감소하였다.
입력이 많을 때는 꼭 sys.stdin을 사용하자.
다른 사람의 풀이를 보다가 깨달은 점이 있는데,
range(start, end, step)을 제대로 사용하지 못하고 있었다.
start값이 초기값이니, 제곱으로 시작하고, step을 더해나가는 값으로 생각해서 만들면 range로도 쉽게 가능하다.
이게 생각나지 않아서 while로 억지로 쓰다니...
마지막으로, 최대 상수는 상수를 만들어서 쓰자.
상수는 오타내면, 찾기가 어렵다. 또한 magic number는 사용하지 않는게 좋은데, 아무생각없이 썼다.

처음에 2를 제거하려고 각종 조건을 다 붙였었다. 다른 사람것을 보니 생각하지 않고 풀었었다.
생각해보니 짝수임으로 2는 처음에 확인만할 뿐, 절대로 추가될 리가 없는 값이였다.
그 잠깐의 계산을 제거하기 위해서 각종 조건을 붙이는 것 보다는 그냥 넣는게 훨씬 깔끔했다.
또한, 예외처리를 미리하기 보다는 prime에서 2만 제거하는게 훨씬 간단했을 것 같다.

아직까지 에라토스테네스의 체를 만드는 것이 어려운 것 같다. 시간이 좀 걸린다.
다만, 이렇게 만든다를 생각하면 쉽게 만들 수 있지 않을까 싶다.

9613번 문제는 간만에 재귀로 풀었다. 재귀가 어떨때는 쉽긴 한데, 오류가 나면 해결하기가 너무 어렵다.

17087번 문제를 재귀로 풀려고 하였으나, N= 10^5여서 런타임 오류로 폭파되었다.
연습 좀 하려고 했더니...

1373번
진수를 변환하는 여러가지 방법이 있다.
bin, oct, hex, int(접두어 값, 진수), format(숫자, 다른진수)
https://www.daleseo.com/python-int-bases/를 참고한다.

n진법 숫자를 10진법 숫자로 변환하는 방법은
https://programmers.co.kr/learn/courses/4008/lessons/12733 를 참고한다.

string을 hex진수로 변환하기 위해서는 encode를 사용한다.
https://doriri.tistory.com/3

2089번
-2진수를 계산하는 방법이 매우 어려웠다.
진수 변환과 같은 방법으로 하면 된다고 하였지만, 아무리해도 답이 나오지 않았다.
이 문제만 1시간 넘게 풀려고 했던 것 같은데, 결국에는 이해하였다.
-2로 나눴을 때, 나머지가 1이나 0이 되도록 조정하는것이 목표였다.
이해하고 나니 편하다.

17103번
check_prime을 True로 만들어두니, 리스트 내포를 사용하기 쉬었다.
이를 풀면서 6588의 문제점을 알아냈는데, 2루트 만큼의 수만 prime에 들어가 있다.
이렇게 구현했는데도 풀린 것을 보면 낮은 값에서 답이 나오는 것을 알 수 있다.
test해보니 1,000,000이하에서는 1000이하의 소수로 골드바흐의 문제가 풀리는 것을 볼 수 있었다.
일단 해결됨으로 수정하지 않고 놔둔다.

20.03.30.
dynamic programming을 시작하였다. 점화식을 잘 세울수 있을지 모르겠다.
가능하다면 Bottom up/top down을 둘 다 구현해보는 것을 목표로 해야겠다.
재귀 최대 깊이 지정은 https://algoshipda.blogspot.com/2015/05/syssetrecursionlimit-limit.html을 참고한다.

1463번
재귀 최대 깊이를 변경하여도, stack size의 제한이 있어 해결할 수 없다.
(exit code 0xc0000fd 오류 발생)
https://bugs.python.org/issue32570
이는 윈도우의 스택은 2MB, 리눅스는 8MB를 잡기 때문이다.
이를 해결하는 방법중 하나는 tread를 사용하는 방법
https://stackoverflow.com/questions/2067637/how-do-i-increase-the-stack-size-in-python
이 있으나, 해결되지 않았다.
어쩌피 dp_arr에 저장됨으로, 1000으로 값을 나눠 계산하고, 깊이 및 stack 사용량을 줄였다.
bottom_up은 전혀 문제가 없다.

dp_arr의 0과 1은 초기값을 넣어주었음으로, bottom up에서 2부터 시작해야 한다.
처음에 0으로 초기화해서 문제가 없었지. 아니였으면 오류가 있을 뻔 했다.

# 20.03.31.
11052 문제는 top_down을 다시보니 문제가 발생할만한 곳이 있었다.
for에서 top_down을 호출하는게 0이 되는지점이 존재하였다.
그런데, dp_arr[num]을 0으로 초기화해서 문제없이 해결되었던 점이 있다.

16194 문제가 매우 어려웠다.
생각하는대로 재귀를 하려고 하였으나, 재귀는 계속 값이 나오지 않아 일단 넘겼다.
그리고 https://takeknowledge.tistory.com/104을 보고 해결하였다.
bottom up도 하다하다 안되서 답지를 보았다.
index부분과 초기화부분이 문제였다 하아..
항상 맨 처음과 마지막을 잘 보는 연습을 해야될 것 같다.
특히 0부터 시작할지, 1부터 시작할지와, num-index가 0을 참조하는지도 고려해야 한다.

이 문제에서는 min함수를 사용할 수 없었고, -1일 때를 고려해야 했다.
dp 구현 연습이 많이 필요하다.

15990문제를 몇 시간 잡아먹었는지 모르겠다.
다른 차이가 없는데 대체 왜 시간초과가 이렇게 나는지 고민했는데,
숫자가 들어올 때마다, dp를 재계산해서 그랬다.
그래서 continue로 넘겨보려고 했지만, 이걸로는 역부족이였는지 계산을 완료하지 못했다.
lazy evaluation(계으른 계산)이 훨씬 빠를 것 같았으나, continue로는 처리하지 못했다.
아무래도 계산이 완료된 최대 값을 저장하고, 그 이하는 계산하지 않는 등의 방법이 필요한가보다.

bottom_up으로 해결할 때는 그냥 미리 계산을 끝까지 해놓고 보는게 좋다고 생각된다.

재귀함수는 http://blog.naver.com/mirusu400/221788252855의 도움을 받아 처리하였다.
재귀함수를 나눠서 써야 되었다.
재귀함수를 나눠서 계산하는 방법은 1463번을 참고한다.
재귀함수에서 정답이 아니여서 비교하였는데, 마지막 num-2의 2와 num-1의 1을 호출하지 않았다.
그래서 따로 예외처리를 해주었다.
이 문제는 재귀함수가 더 어려운 듯 하다.

앞에서 정말 어렵게 풀었더니, 뒤로 갈수록 쉽게 문제를 푸는 것 같다.
에휴 힘들다.

# 20.04.01.
11005번
출력하는 방법이 여러가지가 있는데, 자꾸 한가지만 쓴다.
''.join(reversed(리스트))
for을 사용해서 거꾸로 출력하는 방법
거의 비슷할 것 같긴 한데..

11053번
dp_arr을 1로 초기화하면(무조건 1번은 자기자신임으로) 편하다.
하지만, 재귀로 계산할 때는 계산을 했는지 하지 않았는지 알기 어려움으로 0으로 계산하였다.

이를 재귀로 바뀌는 것이 매우 어려웠는데, sequence를 조각내어 작게 만들다가 계산이 엉망이 되었다.
다시 생각해보니 index만 줄여가면서 보내도 문제가 없다는 결론을 내려 인덱스만 내리도록 했다.
그리고도 계산이 제대로 되지 않아, 일단 넘기기로 했다.

스트레스 받아서 엄청나게 쉬다가, 다시 재귀를 보았다.
일반적인 dp와는 다르게, 이 문제는 다시 한 번 읽어야 되는 문제이다.
그러다 보니 재귀를 해도 줄어든다는 느낌이 별로 없는 것 같다.
재귀를 작성하였으나, 틀리는 것을 보아 알고리즘에 문제가 있는 모양이다.
포기 나중에 생각하자

14002번
11053번도 재귀를 해결하지 못했기 때문에 포기했다.
LIS를 찾기 위해서 재귀를 사용하였는데, 처음에는 lis라는 리스트 변수를 만들었다.
append로 재귀에서 받아와서 마지막에 출력하도록 했는데, 강의 자료를 보니 더 좋은 방법이 있었다.
어쩌피 맨 처음까지 돌아가기 때문에 return에서 출력하면 되는 거였다.
복잡하게 받아와서 출력하지 않으니 더 편하다.

# 20.04.02.
1912번
재귀를 작성했는데 하도 오류가 나서 test코드를 작성하여 점검하였다.
문제가 되었던 부분은, stack이 터지는 것을 막기 위해 1000마다 나누는 부분이 문제였다.
이미 계산된 dp_arr를 재계산하지 않고 return 하는 로직이 없었고,
이 부분을 추가하면서 sequence와 dp_arr의 길이 비교를 했었던 문제가 있었다.
좀 더 함수를 잘개 쪼개면, 더 test하기가 더 편했겠지만, 알고리즘에서 그렇게까지 하긴 힘든 것 같다.
재사용성의 중요성을 test코드 작성하면서 계속 느낀다.

1699번
시간초과가 계속해서 나서 왜 나는지 알 수 없었는데, pypy3로 제출한 이후에 다른 사람의 답을 보니 알 수 있었다.
bottom up에서 제곱을 각각 계산하게 되어 있었는데, 파이썬의 이 부분이 매우 느린 것으로 보인다.
따라서 square변수를 두고, 값을 저장하여 1번만 계산하도록 두었다.
다른 사람들의 글에서는 오래 걸리는 sqaure를 맨 처음에 계산하여 꺼내쓸 수 있도록 해놓았다.

재귀함수는 앞과 같은 방식이라 작성에 실패하였다.
전체를 다시 반복할 때, 문제없이 반복하려면 어떻게 해야할까 흐음..
index를 주는 방법도 있을 것 같은데.

leet SingleNumber
set을 보통 사용하지 않다보니, 너무 오래 걸리는 코드를 작성하였는데, in을 사용할 수 있었다.
답지를 볼 수 있었는데, 수학적인 것 까지는 이해할 수 있었으나, bit연산은 생각지도 못했다
정말 놀랍다.

2225번
3 중첩 재귀함수는 도저히 못하겠다. 포기한다.
3중첩으로 DP를 풀었는데, 빠른 것이 있어서 읽어보았다.
O(n^2)으로 풀었는데, 이게 어떻게 작동하는지 모르겠다.
https://www.acmicpc.net/source/18848782
https://do-rang.tistory.com/7 를 참고한다.

stack limit size 해결하기 - 1463번 stack_test확인 사용
thread로 하면 그래도 어느정도 해결이 된다.
일반 top_down으로 하면 3000정도에서 막히지만,
thread로 하면 409000정도까지 계산한 후에 멈춘다.
이 멈추는 상황이 나타나지 않아서 명확하지 않았지만, stack_size를 조절하니 늘어나는 것을 볼 수 있었다.
다만, 이 스택 사이즈도 한계가 있어서 재귀를 쓰기 좋지 않긴하다.
관련해서 쓸 사이트다
thread
http://pythonstudy.xyz/python/article/24-%EC%93%B0%EB%A0%88%EB%93%9C-Thread
https://soooprmx.com/archives/8834
C stack 한계
https://stackoverflow.com/questions/19406800/what-is-the-ideal-stack-size-for-a-thread-in-python-that-connects-to-a-socket
https://bugs.python.org/issue32570
https://www.reddit.com/r/learnpython/comments/52xewh/need_help_with_0xc00000fd/
thread로 일단 해결보기
https://stackoverflow.com/questions/20629027/process-finished-with-exit-code-1073741571
unix에서만 가능
ulimit로 스택 한도 변경도 가능
http://faq.hostway.co.kr/Linux_ETC/7179
python의 resource로 변경 가능
https://stackoverflow.com/questions/5061582/setting-stacksize-in-a-python-script
https://docs.python.org/ko/3/library/resource.html
stackless python
https://namu.wiki/w/Python#s-4.1

# 20.04.03.
day2 happy number
너무 dp연습만 했나보다. 정말 pythonic한 방법이 있었는데, 그냥 arr에 때려넣고 풀었다.
집합을 잘 사용하지 않았는데, 집합을 사용해보니 중복제거에는 매우 편하다. 사용하는 연습을 해야겠다.

day3 maximum subarray
이전에 배웠던 거라 dp로 풀었는데, 분할탐색으로도 풀 수 있다고 한다.
알고리즘 공부하다보면 나오겠지..?

# 20.04.04.
3085번
간만에 길게 코딩하려니 힘들었다.
항상 마지막 부분을 주의했어야 되었는데, 마지막을 생각 안해서 틀렸다.
다른 사람들도 이런 것이 많았나 본데..

1476번
어제 잠을 안 자서 그런지 엉망이였다.
자꾸 답이 이상하게 나와서 미쳐버리겠네를 반복하다가 정답 소스를 복사 붙여넣기 해서 둘을 비교했다
처음부터 끝까지.
이상한 부분에서 계속 오류가 나면서 같은 숫자가 반복되길래 확인했더니
if문이 jun_years를 만드는 곳에 들어가서 jun_years가 완성되지 전에 비교를 하니 오류가 난 거였다.
이걸 3시간 넘게 찾아서 찾다니 ㅂㄷ

중국인의 나머지 정리의 방법을 이해하였으나, 적용을 시킬수가 없다.
특히 모듈러 연산의 역원을 구하는 방법을 잘 모르겠다.

1107번
brute force는 그럭저럭 잘했다.
비교해서 하는 방법은 생각보다 고려해야 되는 가지수가 너무 많아서 포기했다. 하하하하
나중에 시간나면 해보자

2908번
문자열을 뒤집을 때 [::-1]을 까먹지 말자.
또한, 문자열 비교도 간단하다.

오늘은 대체 문제 3개에 몇 시간을 사용한건지..

# 20.04.05.
google codejam 2020이 있다는 것을 새벽 1시에 봐서 밤새서 문제를 풀었다.
영어 문제이고, 피곤해 죽으려고 했던 것이 있어서 힘들긴 했다.
nesting_depth나 vestigium은 매우 쉬운 문제였다. 해석하고, 고민해서 풀면 끝나는 문제.
parenting partnering returns도 고민하였을 때, 그렇게 어렵지 않은 문제였다.
greedy문제로 볼 수 있는 것 같은데, 아직 배우지 않아서 명확하지는 않다.
다만, 예시는 잘 돌아가는데, 코드를 넣으면 runtime오류가 났다.
이것만 맞추면 round 1진출인데 오답도 아니고 runtime오류가 나니 원..
index문제는 없는 것 같았는데, 알 수가 없었다.
idicium은 대충 고려했을 때, latin matrix를 만들고 행마다 뒤섞으면 문제가 없을 것 같았는데..
답이 틀렸다고 한다. 열을 뒤섞는 건 어쩌피 대칭이라 고려를 안해도 될 것 같았는데 흠..
뭐 하다가 7시쯤 되서 더 이상 못버티고 잠들었다. 어쩔 수 없지.

day4 move zeros
pointer를 두 개 사용하라 해서, 두 개 각각 돌아가도록 했는데, 꽤나 느렸다.
다른 것을 보니 0을 만나기 전까지 같이 포인터가 돌다가, zero가 되면 멈추었다.
그리고 다음 수가 나올 때까지 멈춰있게 되었다.
알고리즘은 역시 어렵다.

day5 best time to by sell stock II
생각보다 쉬웠다. 살 때는 다음이 높을 때 사고, 팔 때는 다음이 낮아지면 팔면 되었다.
그것보다 더 빠른 계산이 있었는데, 보유하고 있다고 생각하고 profit을 계산하는 거였다. 낮아지면 계산 안함.
내가 생각한 것과 유사하지만, 구현이 매우 빠르다는 장점이 있다.

9465번
두 번 받은 값을 zip으로 묶어 list를 확인하기 쉽게 만드는 방법이 있었다.
zip(t1, t2)로 하면, index순서를 dp_arr와 맞춰 헷갈리지 않게 만들 수 있다.
재귀 시간초과가 나는데, 더 빠르게 할 방법은 모르겠다. 하아.

# 20.04.06.
14500번
그려서 보는 것까지 다 만들어두고, 제대로 안 봐서 틀렸다 -_-.
brute force는 자세히 봅시다.

2156번
dp를 고려하였으나, 작동하지 않는다. 넘기고, 다음에 강의를 듣고 풀어야겠다.

1932번
아무생각없이 제출된 코드를 읽다가, 삼각형을 반대로 읽어나가는 것을 보았다.
그래도 더하기의 개수는 같으니, 마지막에 리스트 전체를 검색하지 않고, 한 번에 확인할 수 있다.
오 이건 재미있는 방법인 것 같다.
이번에도 재귀함수는 작성하지 않았다. k와 n의 이중 for문임으로 위와 같이 문제가 발생한다.

6064번
중국인의 나머지 정리를 사용할 수 있는 문제이다.
다만, 아직 이해를 못했으니 brute force를 사용한다.
brute force의 속도를 늘리기 위해, 큰 수가 m이 되게하여 더 빠르게 건너뛰도록 유도하였다.
또한, 마지막을 최대값을 갈 때 까지가 아닌, 최대 공배수까지만 돌도록 하였다.

day6 group anagrams
당황스러운 문제였다. 중복을 없애기 위해 set을 사용하였는데 bob, bo같은 것을 비교할 수 없었다.
그래서 문자열을 전부 분리해서 dict에 넣고 계산하는 방법을 생각하였으나, 시간초과가 났다.
solution이 열려있길래 확인해보니...
key를 만드는 방법이 두 가지였다.
1) string을 sorted하면 list가 나오는데, 이를 tuple로 바꿔 key를 사용하는 방법
2) 각 문자를 ascii로 해석하여 개수 리스트를 만드고 이를 key로 사용하는 방법
이쪽 문제는 풀때마다 신기한 것 같다.

collections의 defaultdict이 존재하는데, 이 dictionary는 기본 값를 설정하여, 없으면 기본 값를 만들어준다.
이 때, 작성되는 값은 list, set등이 가능하다. 좋은 자료형이다.


10250번
정말 간단한 문제였는데, 한 번에 맞추지 못했다. 들어가자마자 틀렸다고 해서 매우 당황했다.
층수는 간단하게 확인했는데, 방의 수는 계산안하고 대충 했더니 그랬다.
질문에 가서 보아서야 내가 뭘 잘못했는지 알았다.
항상 맨 처음과 맨 마지막 부분은 주의해야 한다.

# 20.04.07.
11055번
다른 재귀함수 미작성과 같이 전체 순환을 해야될 때, 재귀함수를 어떻게 작성하는가..는 항상 문제이다.

11722번
가장 긴 감소하는 부분수열을 푸는 문제이다.
어디가 가장 최소인지 알 수 없는게 문제이다.
하지만, list를 뒤집으면 증가하는 부분 수열과 같아서 문제없이 해결할 수 있다.

day 7 counting elements
day 6과 비슷해서 hint를 보고 비슷하게 풀 수 있었다.
dictionary를 사용해서 개수를 저장하고, 그 다음 숫자가 있는지 확인하는 방법이였다.
이상하게 문제가 검색이 되지 않는데 흐음..

15650번
재귀를 구현하려니 생각보다 어렵다.
order는 순서를 결정하는 것으로, 전부 반복하게 된다.
따라서 O(N!)의 시간이 걸린다. (M=N)
선택을 결정하는 것은 재귀를 하는데, 선택을 했을 때, 안했을 때를 나눠서 호출한다.
재귀는 구현하는게 쉽지 않은 것 같다.

2231번
전체를 brute force로 계산할 수도 있지만, 값을 얻을 수 있는 최대 자리수를 계산해서 돌리는 방법이 있다.
https://itadventure.tistory.com/158 를 참고한다.

# 20.04.08.
요즘 하루종일 공부를 했더니 피곤해다.
일주일에 하루는 쉬어야겠다. 조금만 공부하고.

day8 middle of the linked list
자료구조를 해보지 않아서 그런지 대체 뭘 해결하기 원하는 건지 이해하기 어려웠다.
그래서 solution을 보고 해결했는데, 솔루션을 보니 원하는 게 뭔지 이해가 되었다.
두 배 빠르게 넘어가는 걸 통해서 중간을 반환하는 걸 보니 신기한데?

11054번
증가수열 + 감소수열이다.
둘 다 top_down으로 표시하는 건 포기했으니 고려하지 말고 포기하면 편할 것 같다.

13398번
negative만 index를 저장해서 계산하려고 하였는데, 걸어야 되는 제약조건이 너무나도 많았다.
음수가 맨 처음에만 있을 때, 전부 음수일 때, 등등등
포기하고 글을 보니, 제외하고 구해서 푸는 쉬운 방법이 있었..
내일 다시 구현해야겠다.

2292번
각 껍질의 마지막 수를 계산해서 값을 구했는데...
다른 사람의 풀이를 보니, 어쩌피 계속 더해가기 때문에 6*껍질수를 더해가면 되었다.
에휴..

# 20.04.09.
2775번
좀 더 간단하게 나타낼 수 있는데, 어렵게 나타내는 경우가 좀 많은 것 같다.
for index, person in enumberate(people):
    if index == 0:
        continue
    people[index] = people[index-1] + person
로 하지 않고
for index in range(1, n):
    people[index] += people[index-1]
이 보기 더 편한 것 같다.
https://www.acmicpc.net/source/18976802를 참고하였다.

2798번
최근 배웠던 brute force N과 M2번과 같이 선택하는 문제이다.
좀 변형이 되서 max_sum을 구하라고 한다.
return으로 넘겨주면 되어서 넘겨주었는데, 흐음..
아직까지 구현하는데 쉽지 않다. 순서를 구하는 것도 아닌데 for썼다가 시간초과나고..
cards를 나눠서 넘겨줄까 했는데, 그렇게 하기에는 연산이 커지고, 무거워저서 포기했다.
종료조건을 빼먹는 것도 문제이긴 한데.. 하다보면 익숙해지지 않을까 싶다.

2133번
다이나믹 프로그래밍 연습에서 3문제를 풀지 못했다. 그 중 하나가 이 문제이다.
원래 생각에는 완전히 채우지 않았을 때를 고려해서 풀었는데, 그건 답이 없는 것이였다...
다 채운 것만 계산해서 결정하는 문제였다.

2156번
내가 풀었던 방법이랑 같은데 답이 안나와서 답답했던 문제였다.
그런데 강의에서는 이친수랑 같다고 넘어갔다. 이친수 문제를 보고 다시 보니 이해할만한 내용이였다.
그리고 내 코드의 답이 안 나왔던 것은 index가 잘못되서 답이 안나오는 거였다... 한숨.
one dimension dp_arr로도 풀 수 있다는 것은 참 신기한 것 같다.

11722번
오늘 푼 문제는 아니지만, 강의에서 나왔다.
3가지 방법이 있었다.
1) 뒤집어서 증가수열로 풀기
2) 뒤에서 돌면서 증가
3) LIS와 매우 유사하나, 부등호를 바꿔서 계산하는 방법
j<i, A[j]> A[i]이도록 만든다.

# 20.04.12.
집 정리를 하느라 정신이 없어 문제를 풀지 못했다.
집이 정리된 것을 보니 좋긴 한데, 컴퓨터 자리가 이동되서 익숙해지려면 시간이 좀 걸릴 것 같다.

day10 min stack
이틀 전에 풀었던 문제이나, commit하는 걸 까먹어서 이제야 올린다.
이전에 list를 상속받아 stack구현하는 연습을 했더니 생각보다 쉬웠다.
다만, 계속 계산하는 부분이 있어서 느려졌는데, 다른 사람의 답을 보니 신기했다.
list로 만들어 맨 위 값보다 작으면 넣어서 계산하게 만들다니..
복잡하게 계속 계산할 필요가 없었다.

이상하게 내가 만들었을 때는 오류가 나서 index로 고쳤는데,
지금 생각해보니 최소값이랑 같을 때도 리스트에 넣어주면 pop할 때 문제가 없었다.
멍청하면 더 어렵게 만듦니다.

day11 diameter of binary tree
고민해본 결과, 이런 문제는 역시 재귀였다.
재귀함수를 열심히 구현해서 짰더니 답이 나왔다.
그리고 나보다 빠른 답을 본 결과 dfs(깊이 우선 탐색)을 하는 거였다.
거의 유사한 방법인데, 코드가 나보다 짧고, 빠르다.
나중에 배우면 잘 쓸 수 있겠지

1259번
리스트를 뒤집어서 보는 방법은 [::-1]이 있다.

11050번
팩토리얼을 구하는 방법은 math.factorial을 사용하는 방법이 있다.
이항계수를 사용할 수 있는 알고리즘이 3가지가 있다는데, 일단은 안 보고 풀었다.
아마 팩토리얼이 있다보니, 더 빠른 방법들이 있을 것으로 생각된다.
# https://m.blog.naver.com/jdkim2004/220686043201
# https://shoark7.github.io/programming/algorithm/3-ways-to-get-binomial-coefficients

15654번
빠른 사람들이 있는데, 대부분 순열로 풀었다.
순열은 다음 차시니 넘긴다.

# 20.04.13.
day12 last stone weight
list를 만들고 단순하게 sorting 했다.
파이썬에는 heapq라고 하는 이진 트리를 기반으로 하는 힙이 있다고 한다.
최상단에는 가장 낮은 값이 올라온다. 삭제 및 추가에 O(logN)이 걸린다고 한다.
https://www.daleseo.com/python-heapq/

15656번
리스트의 sort함수는 숫자일 때와 문자열일 때 정렬방식이 다르다.
1 9 11 22/'1', '11', '22', '9'
정렬 시 주의한다.

15663번
collections에 있는 Counter를 사용하였다.
같은 값이 몇 개 있는지 저장하여, Counter를 반환하는데, dictionary처럼 사용해도 괜찮다.
Counter에 대해서는 다음을 참고한다.
https://excelsior-cjh.tistory.com/94
답에서 zip에 *을 사용하는 것을 보았는데, 이는 컨테이너 타입의 데이터를 unpacking하기 위해서 사용했다.
https://mingrammer.com/understanding-the-asterisk-of-python/

# 20.04.14.
day13 contiguous array
보통 풀던 문제보다 어렵다는 생각을 했는데, medium문제였다.
처음에는 0과 1이 나오다가 바뀔 때 개수를 파악하게 만들었는데, 문제를 잘못 해석한 거였다.
0과 1이 같은 양이 있는 부분수열의 길이가 문제의 핵심이였다.
결론적으로 solution의 도움을 받았다.
solution을 대충 이해하고 내 식대로 문제를 혼합했는데, 다른 곳은 괜찮았지만, 맨 처음이 문제였다.
처음에 넣는 인덱스 값을 바꾸고 하다가 생각해보니, index 0에 대한 초기값을 주면 해결되는 것이였다.
0에 대한 인덱스를 0으로 줬더니 홀수가 나와서 어떻게 할지 고민했었는데, 단순하게 -1로 해주면 되었다.
주식시장처럼 움직이는 것으로 생각하는 건 신기한 것 같다.

hash를 통해 해결하는 방법이 있었는데, 포기했다.

10972번
순열로 넘어가서 순열 문제를 풀었다. 이해했다고 생각했는데, 막상 해결하려고 하니 생각보다 헷갈렸다.
가장 문제가 된 부분은 swqp_number를 넣어줄 때, 어떤 값을 넣어줄지가 문제였다.
len()을 통해 가장 큰 값을 넣어주었는데, 이번에는 같을 때가 처리되지 않아 계속 터졌다. 어휴.
print를 할 때, 리스트 내부값을 unpack하여 간단하게 출력할 수 있었다.
print(*변수명)을 사용하면 unpack이 가능하다.
다른 사람 코드를 뒤적거리다보니 이런 것이 있어서 가져왔다.

# 20.04.15.
day 14 perform string shift
2주차 문제다. 저번에도 1주차 마지막 문제는 leetcode의 홈페이지에 없었는데, 이번에도 없었다.
문제가 그렇게 어렵지 않아서 간단하게 접근할 수 있었다. 다만, index 문제가 항상 걸리는게 문제였다.
여기서 생각해봐야 되는 건, 0과 1이였기 때문에, if flag:만 가지고도 if문을 작동시킬 수 있었다.
%연산을 간단하게 처리해서 확인해봤는데
-7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 로 인덱스가 움직인다고 해보자.
-7 % 7 = 0이다.
-8 % 7 = 6이다.
인덱스로 계산해보자면, 맨 뒤로 가는 것을 볼 수 있다.
따라서 +, -연산을 할 필요없이. 그냥 % 연산을 해주면 원하는 값이 나온다.
또한 %연산을 여러 번 하여 값을 줄인다면, 마지막에도 %연산을 하는 것을 까먹으면 안 된다.

10973번
이전 순열을 구하는 문제이다.
for 내부에 다 집어넣어서 가독성이 떨어지는 느낌이 있긴 하다.
break를 걸어서 for을 전부 밖으로 빼주었으면 더 보기 좋았을 것 같기도 하다.
예시이다. https://www.acmicpc.net/source/19021804

10971번
예외처리를 할 때, 모든 경우의 수를 따지는지 주의한다.
마지막에 비용값을 계산하는 방법이 한 번 들어가는데, 그 값이 0인 경우를 처리하지 않아 틀렸다.

# 20.04.16.
day15 product of array except self
space를 O(1)로 만들라고 해서 대체 어떻게 쓰냐라는 생각이 들었는데..
ans를 사용하면 O(N)이 되는게 아닌가 싶다. 흐음.
암튼 dp를 사용하지 않고, 내부에서 돌아가면서 계산할 수 있다는 점은 흥미로운 것 같다.

day16 valid parenthesis string
error를 정말 여러 번 내고 푼 문제이다.
asterisk가 추가되니, stack에서 처리해야 되는 부분이 있었는데, 그 부분을 고려하는데 시간이 오래 걸렸다.
testcase도 매우 복잡해서 헷갈렸고...
다 만들고 생각해보니 stack에 꼭 append할 필요는 없는 것 같다.
그냥 +1, -1로 해도 별 문제 없었을 텐데, 괜히 공간 차지가 된 것 같다.
greedy방법은 독특한데, (과 )의 개수를 따로 계산해서 둘 다 만족하는지 확인한다.

9095번
이전에 DP로 푼 방법이나 재귀로 다시 풀었다.

1759번
재귀를 통해 푸는 것과 조합을 통해 푸는 것 두 가지를 동시에 해보았다.
n개중 c가지수 선택은 조합을 사용하는게 편한 것 같다.
조합을 사용하는 방법은 https://ourcstory.tistory.com/414을 참고한다.

14501번
재귀로 풀 때, 이렇게 만들면 될 것 같다고 생각해서 만들었더니 어느정도 작동하였다.
select부분이 문제가 되서 수정해주니 잘 작동했는데, 다시 천천히 분석해보니 대체 왜 동작하는지 모르겠...
그래서 천천히 돌리다보니까 이해가 되었다.
재귀가 쉽다는게 이런 소리였나... 왜인지 모르겠지만, 문제가 해결된다는 거?
간만에 dp로 풀어보았다. 이게 dp인지는 헷갈리지만, 일단 계산된 값을 미래로 보내서 저장했다.
dp맞겠지...?

# 20.04.17.
14889번
조합과 재귀로 문제를 풀었다. 조합이 brute force에서 쓰기에는 매우 편한 것 같다.

15661번
별별 짓을 다했으나, python3로는 해결하지 못했다.
이전 combination과 recursion을 가져와서 했을 때는 느렸다.
새로 recursion을 작성하였으나, 이걸로는 부족하여서
fast_loop로 1-len(stats)//2 + 1 까지만 돌아 확인하도록 했다.
t1, t2가 어쩌피 대칭임으로, 반만 계산해도 문제가 없다.
하지만 이것도 python3에서는 시간이 부족했다.
더 빠른 재귀를 고민해봐야겠다.

2529번
재귀에 점점 익숙해지나보다. flag를 통해서 원하는 최대/최소만 구하게 만들기도 하고...
중간 return에서 True와 False를 혼합했는데,
일관성을 위해서는 답이 나왔을 때 True로 변환하는 것 외에는 전부 flag를 return하는게 이해하기 쉬울 것 같다.

1248번
복잡했었던 부분이 많았는데, +/-/0을 1/-1/0으로 바꿔 sign을 곱해줌으로서 간단해졌다.
분명 같은 알고리즘인데, 나는 안돌아가고 다른 건 돌아간다.
https://www.acmicpc.net/source/18474112와 답지를 보면서 비교했다.
차이가 있었던 부분은 check부분을 sum으로 해서 계산하는 부분이였는데,
이 부분에 의해 약 O(n)이 더 걸려서 시간이 오래 걸린 것으로 파악된다.
답지를 보고 index를 뒤로 돌게 하여 s를 더하도록 만들었다.
이런 간단한 차이가 5배 정도 느리게 만든다는 점이 참으로 놀랍다.

# 20.04.18.
day17 number of islands
처음에는 검색하면서 '1'로 간 뒤, 대충 오른쪽, 아래를 탐색하여 탐색완료인 2로 바꾸는 것을 생각했다.
이후 탐색시 2를 만나면 같은 섬으로 판단하도록 생각했다.
그런데 그 섬을 돌면서 같은 섬이여도 재귀에 의해서 만나다보니 같은 섬으로 판단되는 문제가 있었다.
그래서 포기하고 전부 확인하게 만들고, 확인된 섬은 0으로 바꾸도록 작성하였다.
그래서 통과하는 것을 보았는데, 같은 방법인 사람들이 dfs라고 소개하고 있었다.
흐음..? 나도 모르게 쓰는건가.

11723번
계속 time out이 나길래 소스와 비교했다.
all부분을 for을 돌리지 않고, 최대를 만든 후 -1을 하면 간단하게 만들어지는 것을 볼 수 있었고,
empty도 반복하는 것이 아니라 0으로 처리하면 매우 간단했다.
not을 반복하는 방법이 매우 느리다는 것을 알 수 있었...
약간의 차이인 것 같은데, time out이 나는지 안나는지가 보이는 걸 보면 참...
15661번도 비슷하지 않을까 싶다.

1182번
전체를 돌기 위해서는 1<<len()을 해주면, 끝이 포함되지 않기 때문에 전체가 1111일 때까지 확인할 수 있다.

# 20.04.19.
day18 minimum path sum
거의 비슷한데 속도가 느려서 신기했다.
if문의 조건이 어떤가에 따라 속도차이가 나는 걸로 보인다. 조건만 바꾸었는데 60ms차이가 나다니...
참 신기한 일이다.
조건을 많이 다는 것보다, 많이 처리하는 부분을 else로 넘겨 계산하게 만드는게 훨씬 빠른 것으로 보인다.

14391번
수업을 들을 때 bitmask를 row major로 계산할지, column major로 계산할지를 다르게 해서 풀면 되는 줄 알았다.
bit mask를 고정하고, 각 값에 대해서 계산하는 것이기 때문에 이렇게 풀면 안된다.
행을 우선으로 돌든, 열을 우선으로 돌든 row major를 계산할 수 있는 점을 착안해서 풀어야 되는 문제였다.
양쪽을 하지 않고, 한 쪽만 한다면 쉽게 풀리긴 한다. 흠. 답지를 보니 이중 for문으로 검색하도록 되어있었...
암튼 row major number의 행은 j//col, 열은 j%col로 계산할 수 있다.

그리고 계속해서 틀렸습니다가 나와서 답을 찾지 못하고 있었다.
아무리 비교해도 코드가 비슷한데, 왜 틀리는지 알 수 없었는데...
test case를 brute force로 넣으니 3*2가 이상한 것을 볼 수 있었다.
사유는... row major number를 계산하기 위해서는 col을 사용해야 되는데 row를 곱해줘서 number가 건너뛰어지고 있었다.
한숨.

# 20.04.20.
13023번
강의에서는 이것저것 사용해서 다 돌렸지만, dfs를 통해서 깊이 탐색을 해보았다.
처음 적용해보는 거라 쉽지는 않았다. 모든 정점을 다 확인해봐야 된다는 점을 고려하지 않아 두어번 틀렸다.
질문을 보니, 모든 정점에 대해서 확인하는 all부분이 빠진거였다.
처음 적용은 어려운 것 같다.

day19 search in sorted array
이진 탐색을 모르는 상태에서 접근하니 풀이가 엉망이였다.
시간이 없어서 일단 복붙으로 제출하고 보았다. 이후, 공부해서 풀어보았다.
이진 탐색은 여기서 읽어보았다.
https://wayhome25.github.io/cs/2017/04/15/cs-16/

생각보다 재귀를 예쁘게 못 꾸민다는 생각이 들었다. 전부 return해줄 필요는 없구나.
암튼 다 꾸미고 여러가지 면에서 고민을 했는데, 조건이 더 필요하다는 생각이 계속 들었다.
계속 틀리기도 했고.. left부분이 제일 클 때가 항상 오류나는 조건이였다.
여러가지를 고민하였으나, 답이 없어서 dicussion을 뒤적여보았다.
https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/587261/Python-recursion-O(log-n)-11-lines-easy-to-understand
를 참고해서 해결하였다. 아예 조건을 고민해보는 것도 좋은 것 같다.

day20 construct binary search tree from preorder traversal
일단... 뭘 질문하는지부터 알아보아야 되었다.
traversal이란 트리를 순회하는 방법을 이야기한다.
preorder traversal은 루트 노드에서부터 다음과 같은 방법으로 노드를 방문한다.
- 노드를 방문한다.
- 왼쪽 서브트리를 전위 순회한다.
- 오른쪽 서브트리를 전위순회한다.
https://gnujoow.github.io/ds/2016/09/01/DS4-TreeTraversal/

이진탐색트리가 무엇인지는 다음을 참고했다
https://ratsgo.github.io/data%20structure&algorithm/2017/10/22/bst/

다 만들어 놓고, 왜 답이 안나오는지 엄청나게 고민했는데...
right와 left를 반대로 해놓았다. 허허.

# 20.04.21.
1260번
아무리 생각해도 뭐가 터지는지 알 수 없어서 빡쳐있었다.
알고리즘 문제는 없는데... 하면서 계속 보았지만, 런타임오류는 계속 나고.
재귀가 아직 터질리가 없는데 하면서 재귀를 스택으로 고쳤지만 또 터졌다.
사유는 입력받는 값 초기화에 있었...
리스트를 정렬할 때 v_num으로 돌렸어야 되었는데, e_num을 적어놓았으니 터지지.
하하하하하하
암튼 둘 다 구현한 것으로 만족하기로 한다.

# 20.04.22.
day21 leftmost column with at least a one
처음에 문제를 잘못 읽어서 이상한 짓을 했다.
binary이고, 행이 오름차순으로 배열되었을 때 첫번째로 1이 나오는 열을 찾으라는 거였는데...
열이 오름차순이라고 생각해서 오름차순으로 놓고 풀었다가 틀렸다. 허허..
hint를 보고 적절하게 알고리즘을 만들긴 했는데, 자꾸 범위를 벗어나서 힘들었다.

interactive 문제라고 해서 고민했는데, 아직도 뭐가 다른 건지 모르겠다.
흐음..

2667번
day17 number of islands와 유사한 문제이다. dfs라고 해서 뭐지 하고 있었는데, 배워보니 dfs이다.

4963번
2667번과 거의 유사하나, 정사각이 아니고, 대각선도 확인해야 되었다.
정말 유사해서 재사용이 가능할 정도였다.
DXY만 고치고, test case초기화 부분만 수정해서 제출했더니 성공하였다.
역시.. 유연하게 만드는게 중요한 것 같다.

7562번
속도가 느려서 다른 사람 것을 보니 step까지 넣어서 큐를 진행하는 것을 보았다.
step을 받아오는 부분이 느린가 싶어 step을 넣도록 변경했으나, 속도의 변화가 거의 없어서 그대로 진행했다.

# 20.04.23.
day22 subarray sum equals k
포인터 두 개를 사용하는 것으로 계산을 했지만, 여기 저기서 오류가 났다.
solution이 열려있어서 보았더니, 같은 방법외에 hash map을 사용하는 방법이 있었다.
답지를 봤을 때는 ???? 하고 있었는데, discussion에 가서 다른 사용자가 구현한 것을 보니 쉬웠다.
dict을 사용해서 합을 저장하고 지금까지 더한 값에서 k를 빼서 그 합이 있는지 확인한다.
sum[i] - sum[j] = k임으로
sum[i] - k = sum[j]이다. 따라서 sum[j]가 존재하는지를 확인함으로, 이러한 방법이 성립가능하다.

day23 bitwise and of numbers range
고민을 조금 해보았다.
우선, 값을 늘리면서 변화를 보자.
차이가 0이면 0bit, 1이면 1bit, 2-3이면 2bit, 4-7이면 3bit, 8-15이면 4bit가 변화한다.
이때, 하위 bit가 변한다면 그 값은 사용할 수 없다.
8 같은 경우를 보면 하위 비트가 다 변화한 후, 1000이 됨으로 4번째 bit가 무조건 변화하여 사용이 불가능하다.
따라서 끝과 첫번째를 and연산하여 살아남을 수 있는 bit를 구한다.
그리고, 값의 차이보다 하나 더 큰 bit를 구한 후
(1 << bitnum) >= number_count
여기에서 1을 빼줘서 not연산 후 and를 시키면 하위 비트를 삭제할 수 있다.

16929번
이전 위치를 확인하는 문제가 있어서 board의 값을 지워버렸다.
그리고 곰곰히 생각해보니, 대체 이게 어떻게 풀린 건가에 대해서 고민하게 만들었다.
지워졌는데 같은 값을 찾아?
생각해보니 queue에서 나올 때 값이 비기 때문에 마지막은 확인한 상태지만, 값이 남아있을 수 있었다.
뭔가 우연히 오류를 해결한 느낌이다.
check를 없애도, 값을 안비우고 continue를 해도 문제가 발생하는 것 같은데 흠.
dfs로도 풀 수 있을 것 같았으나, 귀찮았다. 거의 유사한 방법이기도 했고.
쓸 때 없이 함수 전달을 빼버리고 코드를 간결하게 만들었다.

# 20.04.24.
16947번
정 모르겠어서 강의를 들었다. dfs를 통해서 순환을 찾고, bfs를 통해서 값을 구하는 것이였다.

다 맞은 것 같은데 왜 틀렸을가를 고민했다.
답은 check대신 subway를 점검하고 있어서, 그 부분의 점검이 안되고 있었던 거였다. 어휴.
꼼꼼하게 점검하고 있으니, loop를 확인하는 과정에서 오류가 보였다.
탐색 값에 0을 넣었을 때와 1을 넣었을 때가 달랐는데, 사유는 마지막에 pop한 부분을 append하지 않아서였다.
대체 index로 랜덤하게 했을 때 왜 된거지...??
참 컴퓨터는 알 수 없다.

16940번
문제를 잘 읽어야 한다.
놓쳤던 조건
1. N개가 무조건 들어오기 때문에, 덜 입력될 가능성은 없다.
2. 시작은 무조건 1이여야 한다.
2.를 놓쳐서 다른 부분을 고쳤다.

9328번
오류는 거의 다 해결했는데, 자꾸 틀렸습니다가 나왔다.
문서를 훔친 뒤, 뒤쪽을 가는 경우를 생각하지 못했던게 문제였다.
문을 열든, 키를 가져가든, 문서를 훔치든 그 다음도 가야 문제가 해결되었다.
그래서 자유게시판에 발생할 만한 문제를 적어두었다.

# 20.04.25.
day24 lru cache
이전에 운영체제에서 보았던 기억이 있어서 기억나는 방법으로 풀었다.
queue를 이용하는게 답이였다. store를 list로 구현할지, dict으로 구현할지 고민하다가 key자체가 index가 아니였다.
그래서 dict으로 두고 만들었다.

답을 보니 collections에 있는 OrderDict을 사용해서 구현하였다.
OrderDict은 받아온 순서를 기억하는 dictionary이다.
https://excelsior-cjh.tistory.com/98 를 참고했다.
일반적인 dictionary와 같으나, move_to_end와 popitem이 추가되었다.
move_to_end는 True일 때 맨 오른쪽으로 넘기고
popitem은 True일 때 LIFO(queue)로 출력하고 False일 때 FIFO(stack)으로 값을 삭제한다.

16964번
이번에도 100%에서 틀렸는데, 처음이 1이 아닐때를 확인하지 않아서였다. ㅂㄷ
오늘은 공부가 안되서 짜기 싫다 하면서 아침부터 저녁까지 놀면서 짰는데, 저녁때 대충 푼게 잘 돌아갔다.
어휴..
신기하게 all(check[1:])을 점검하는 것과, 그냥 return으로 끝낸 것과 차이가 없었다.
O(n)만큼 차이가 나야되는거 아닌가.
암튼 node를 넣고, next_node가 존재하면 넣고, 없으면 다시 pop해서 있는지 확인하는 거였다.

4358번
그냥 dictionary로도 풀 수 있었지만, 이전에 leet code에서 풀었던 defaultdict이 떠올라서 defaultdict으로 풀었다.

# 20.04.26.
problem3 bad user
다 풀어놓고 마지막의 중복이 해결 안되서 포기했던 문제다.
다들 어떻게 풀었나 봤더니 set을 통해서 중복을 해결했다.
결국 비슷하게 풀었네.
itertool의 product를 통하면 모든 조합을 쉽게 구할 수 있다.

17143번
instance를 만드는게 편할 것 같아서 만들었다.
그리고, 시뮬레이션을 그냥 돌린 사람보다 느린 것을 보고 슬펐다. ;ㅅ;
한 번 치고 다음 칸을 가는 경우는 board_size가 1적은 것으로 보는게 편한 것 같다.
0 1 2
  6 5 4
7 8 9
//와 %로 행과 열을 계산하는게 편하다.
반대로 오는 경우는 index를 다시 넣어서 계산하면 편해진다.

매직 메서드를 몇 개 넣었는데, 생각보다 잘 작동했다.
OOP는 거의 구현해 본 적이 없는데, 그래도 이론은 아는지 구현이 가능하다.

# 20.04.27.
공부가 잘 안된다. 아무것도 하기 싫다. 으아아아.

day26 longest common subsequence
아무것도 하기 싫지만, 오늘자 문제는 풀어야지.
hint를 다 보았지만, 머리속에 들어오지 않고.. 이짓저짓하다가 다른 사람의 답을 보고 풀었다.
어쩌피 완전탐색을 해야되는 문제였다.
dp_arr을 1씩 더 주었는데, 한 쪽의 text가 없으면 0이기 때문이다.
dp[i][j]를 text1의 i번째까지와 text2의 j번째까지의 LCS로 생각하자.
이때, 값이 증가하는 상황은 i와 j의 문자 값이 같을 때이다.
즉 dp[i-1][j-1] + 1인 상황만이 가능하다.
dp[i-1][j]와 dp[i][j-1]인 상황을 보면, i나 j가 그대로 있는 상태에서는 LCS가 증가할 수 없다.
이미 LCS가 증가한 상황만이 가능하기 때문이다. (dp자체가 LCS임으로)
그렇다면 같지 않을 때, 나머지 부분은 어떻게 채울 수 있을까?
이전의 i-1과 j-1 중 LCS가 큰 부분을 가져오면 된다.
즉 같지 않을 경우에는 dp[i][j] = max(dp[i-1][j], dp[i][j-1])이 되게 된다.
이때, 맨 앞 부분을 0으로 채워야 함으로, index를 잘 고려해주면 된다.
https://doromi.tistory.com/104
해석에 이 부분을 참고하였다.

day27 maximal square
처음에 brute force로 푼 것도 생각보다 잘 작동했다.
backtracking을 할 수 있도록 구현해서 그런지 60ms정도만 차이가 났다.
그리고 solution을 보니 dp문제로 풀 수 있었다.
듣고 보면 맞는 말인데, 이걸 떠올릴 수 있을지는 모르겠다. 흐음.

5427번
맨 처음에 탈출하는 부분을 제외한다는 생각이 없어서 망했다.
뒤적뒤적하니 질문들이 있어서 해결할 수 있었다.
시간을 보니 3.3s정도 걸리고, 빠른사람은 2초 초반에도 풀길래 소스를 보았다.
if문으로 하드코딩 되어 있던데 흐음..

빠르게 하기 위해서 처음 for문에서 @을 찾을 때를 변경해보았다.
(2중 for문을 2번 도는 걸 1번으로 감축)
- 약 10ms차이로, 이 정도면 그냥 서버 속도 차이로 볼 수 있을 것 같다.
count를 확인하기 위해 dequeue를 확인하는 부분이 있었다.
이 부분을 temp처리해서 수정해본 결과 약 100ms정도의 차이가 있었다

더 빨라지려면, if문으로 구성해야 될 것 같다.

# 20.04.28.
2146번
못 풀고, 강의를 들었다.
bfs를 여러 번 돌리는 방법이 있지만, 그 외에 어떻게 접근해야 되는지 감이 오지 않았다.
방법은 섬을 구한 후, 거리 맵을 따로 만들어서 섬을 확장한다.
그리고 거리에 대한 맵을 따로 만들어서 거리도 마찬가지로 확장하는 것이다.
그리고 섬이 확장되다가 다른 섬을 만난다면, 그 사이의 거리를 더하여 다리의 길이를 구하게 된다.
둘을 분리해서 생각한다니.. 새로운 방법이다.

1424번
조건대로 푼 것 같은데, 뭐가 문제인지 모르겠다.
모든 cd에 최대 노래가 들어가지 않는다고 하는데, 왜 안 들어가는지 모르겠다.
나중에 다시 시도해보자.

17619번
node를 통해 이중 링크드 리스트를 구현해보았다.
그리고 장렬하게 시간 초과 및 망했다. 하하?
그리고 주어진 반례를 돌려보니 많이 틀리는 것을 볼 수 있었다.
이런 유사한 문제는 뭘로 자료구조를 잡아야 될지 모르겠다.

day28 first unique number
leetcode를 하면서 배웠던 defaultdict을 사용해보았다.
deque에 다음에 될 수 있는 unique 값을 넣었다. 그러면서 dictionary에 1을 추가했다.
find_next_unique함수를 제작하여 dictionary의 값이 1이 아니면 queue의 값을 계속 뽑도록 했다.
while else문을 사용해서 완전하게 끝나면 unique의 값이 없으니, None이 되도록 했다.
- 쓰면 안좋다고 하는데, 쓰다보니 마음에 드는 문법이다. 흐음.
add에서 문제가 발생했는데, unique가 없을 때를 고려하지 않아서 문제가 발생한 거였다.
이거 풀다가 지하철에서 멀미를 했다. 어휴...

# 20.04.29.
1697번
간단한 문제였으나, 구성하는 방법이 떠오르지 않아 고민하기도 했다.
next_node같은 경우 for을 구성하는 것이 떠오르지 않아, if문으로 추가 했었다.
통과 이후 느려서 다른 사람의 코드를 참고하니 for문을 통해서 정리하는 방법이 존재했다.
함수를 구성하는 것보다 훨씬 깔끔했다.
그리고 고려해보지 않았는데, 2배로만 순간이동을 하기 때문에 큰 수에서 작은 수로 갈 경우에는 -1만 가능했다.
그 부분을 넣었더니 꽤 속도가 빨라졌지만, 내가 낼 수 있는 속도는 여기까지 인것 같았다.
+ 술먹고 만져서 뭘 푸는지 모르겠다는 생각도 있었다.

13913번
1697과 유사하지만, 값을 추적해야 했다.
move_pos를 통해서 값을 추적하는데, 왜인지 모르겠지만 런타임 오류가 났다.
아무리 생각해도 문제 되는 부분이 없는 것 같았는데...
고민하다가 보니 recursion을 사용하면 문제가 되는 부분은 stack이 터지는 것이다.
보통 1000회까지는 괜찮고, 계산상 1000회를 넘지 않을 것 같았는데, recursionlimit를 10 ** 4로 수정했더니 통과했다.
아무래도 값이 1000 이상이 나오는 경우가 있었나보다.
어느 부분인지 모르겠지만...
거의 이분탐색 느낌이라 훨씬 적은 횟수가 나올 것 같았는데, 왜 터졌는지 모르겠다.

14226번
술이 덜 깼었는지, 풀면서 뭘 푸는지 모르는 상태로 풀었다.
지하철에서 풀면서 딱 집에 도착할 때쯤 성공했다.
가장 큰 문제는 처음에 emoticon으로 인수를 받고, 중간에 emoticon을 사용해서
항상 같은 값이 나왔는데, 내리기 전에 왜 그런지 확인해서 제출할 수 있었다.
다만, 값을 다 계산한 뒤 max를 통해 한 번 더 확인하다보니 다만 속도가 너무 느리다는 생각이 들었다.
처음 떠오른 것은 최소 time값을 구하기 때문에, 가장 오래 걸리는 시간은 emoticon의 갯수와 time이 같을 때였다.
그 때 max를 통해 return하도록 만드는 것이 어떻까 싶었다.
이후 좀 더 고민해보니, next_emoticon이 find_emoticon이 될 때가 최소였다.
일단 한 번 나왔다는 것이 최소의 값일테니.. 그 때 반환하도록 했다.
그래도 빠른 속도인 90ms까지는 안나왔는데, 값을 dictionary로 저장하지 않아서가 아닐까 싶긴 하다.
초기화 시간도 있으니...

13549번
start에서 시작해서 원래대로 가는 것으로 배워서 그대로 풀었다.
bfs인데 간 node를 체크하지 않아서 두어번 틀리긴 했지만...
이번에도 속도가 빠른 것을 보니 뭔가 독특하게 bfs를 취했다.
end에서 돌아가던데, 속도가 왜 더 빠른지 알기는 어려웠다.
https://www.acmicpc.net/source/12222800
비슷하게 꾸며서 돌려본 결과는 약 20ms 더 빠르던데.
이놈은 bfs와는 좀 다르게, 시간이 작지 않으면 한 번 더 들어가게 되어있다.
참 이상하단 말이지.. 그럼 더 돌아야 되지 않나.
암튼 90ms까지는 못줄였지만. 대충 원하는 만큼은 된 것 같다.

# 20.04.30.
day29 binary tree maximum path sum
고려하진 않았지만, 풀고보니 dfs를 통해 푸는 거였다.
이전에 tree관련 문제를 풀었던 기억이 있어서 마지막 탐색이 node가 None인지 아닌지로 간단하게 만들었다.
전달해주는 값이 지금까지 가장 큰 값과 이번 node에서 덧셈을 한 값을 전달해줘야 되었다.
다만 실수했었던 점이 있었다.
왼쪽에서 온 값과, 오른쪽에서 온 값에 node를 더하는 것과 그냥 node중에서 어느 것이 큰 지 고려했어야 되는데,
node의 값만을 고려하는 걸 까먹어서 값이 이상하게 돌았다.

다른 사람들의 답을 보니 하나로 고려해서 푸는 것을 보았다.
self.max를 두어서 값을 저장하게 만들어 값을 전달하지 않아도 되게 만들었다.
또한 math에 .inf라는 상수가 있어서 무한대의 값을 가지고 있을 수 있다.
새로운 방법을 알게 된 것 같다.

1261번
100%에서 틀려서 고민했는데.. 0, 0일 때 None이 출력되었다.
속도를 좀 희생해서 queue를 더 돌리는 것으로 생각하면 간단하게 해결된다.
흐음..

1991번
leetcode에서 트리를 가끔 풀어서 어렵지 않게 구현이 될 것 같았다.
Node를 작성하지 않고, 인접리스트를 통해서 해결했다.
트리를 풀 때 가장 문제가 되는 부분은 탈출 부분인 것 같다.
이 부분에서 항상 오류를 만드는 것 같다.

1018번
간단한 bruteforce문제이다. 가지수는 약 23만개.
행 별로 값을 기억한 뒤, dp를 계산해도 풀 수 있을 것 같으나, 그만한 노력을 들일 필요가 있는지 모르겠다.
3차원 배열이 되는 것도 좀 걸리고..

다른 사람의 코드를 읽다보니, 코드 길이를 줄일 수 있는 방법이 떠올랐다.
white와 black일 때를 각각 나눠서 계산하지 않아도 되었다.
white일때와 black일 때는 64개를 나눠 먹는 것과 같다.
한 쪽이 완전히 black으로 시작할 때와 같으면 다른 한쪽은 64개가 된다.
그런데, 하나를 바꿔서 black으로 시작할 때가 1개 늘어나면 다른 한 쪽은 1개가 맞아져서 63개가 된다.
그렇다고 해서 속도가 빨라지지는 않았다. 84ms이네..

# 20.05.01.
day30 check if a string is a valid sequence from root to leaves path in a binary tree
일요일마다 나오는 문제는 leetcode에서 새로 만든 문제 같던데 이름이 왜 이리 긴지 모르겠다.
어제 tree를 배워서 좀 더 이론적으로 접근할 수 있었다.
preorder로 접근한 후, 풀어나가면 되는 간단한 문제.
항상 그렇듯이 종료조건에서 error를 계속 내뿜는게 문제다. 하아.

2250번
처음 시작하자마다 틀렸습니다가 나와서 당황했다.
일단 너비를 구할 때 1을 더했어야 되었는데, 더하지 않아서 문제가 발생한 것이였다.
그리고 root가 꼭 1이라는 보장이 없다고 해서 root를 구하는 것을 만들었다.
그래도 자꾸 틀렸다고 해서 나중에 다시 풀어보기로 한다.

저녁때 풀어보았다. 계속 봐도 문제가 없는 것 같았다.
혹시하는 마음에 find_ans부분에서 key를 list로 저장하고, sorting해서 제출했다.
잘 맞았다. 왜 sorting을 안하고 풀면 틀리는지 모르겠지만...
암튼 풀렸으니 된 것 같다. 아마 min부분에서 오류가 있었던 것 같은데.. 흐음.
대충 계산했더니 답이 나왔다.
2가 19이고 4가 20이라고 하였을 때, min_level에 2가 저장되고 max_width가 20이 된다. 어휴.

input_value를 보다보니 줄일 수 있는 부분이 있었다.
node로 첫 번째 값을 받고, 중간은 *binary로 다 받아주면 해결된다.
좀 더 보기 좋고 리스트를 두 번 만들필요가 없으니 더 좋은 것 같다.

다른 사람의 답을 보니, 재귀로 안 터지는 경우인 듯 해서 재귀로 해결해보았다.
하지만 속도가 같다는 점이 함정이다.

11725번
트리를 탐색하여 최단 거리를 구하는 것은 BFS로도 가능하다.
cycle이 없어 경로가 1개이기 때문이다.

1167번
leetcode에서 많이 보던 문제이다.
다만, tree임으로 binary라는 보장을 할 수 없다는게 문제.
또한, 깊이를 예측할 수 없어서 stack을 구현해야 되서 귀찮았다.
dfs를 통해서 풀면 더 빠를 것 같긴 한데.. bfs 두 번 보다는 한 번이 빠르니.
binary tree가 아니여서 고민할 것이 많다. 귀찮다.

강의에서 지름을 구하기 위해서는 bfs를 두 번 구현하면 된다고 했는데, 증명이 잘 이해되지 않았다.
짜증나서 잠들었는데, 꿈에서 알고리즘을 풀고 있었다. 어휴
깨어나서 좀 움직이니, 당연한 이야기라는 것을 알 수 있었다.
tree는 어느 부분을 잡아도 root가 될 수 있다.
이를 고려한다면, 랜덤한 정점을 잡아서 가장 먼 거리를 간다면, 가장 끝에 있음을 알 수 있다.
그리고 그 곳에서 맨 끝을 찾아 간다면, 당연히 가장 먼 거리를 이동했다는 것을 알 수 있다.
복잡한 수식 없이 대충 본거지만, 맞다는 생각이 든다.

# 20.05.02.
day1 first bad version
5월이 되어서 새로 시작했다.
첫 주-두 번째 주는 간단한 문제들이 나올 것 같다.
이분탐색의 구현이였는데, 이전에 leet code문제에서 처음 접근해본 적이 있어서 간단하게 구현했다.
다만... python은 overflow가 안나지만, overflow를 주의하기 위해 mid의 구현을 조심해야 된다는 솔루션을 보았다.
mid = (start + end) // 2 보다는 mid = start + (end - start) // 2로 구현하라는 것이다.
새로운 것을 하나 더 배우고 간다.

10816번
속도차가 좀 있어서 이것저것 테스트 해보았다.
ans를 만들고 ' '.join(ans)를 하는 것이 제일 빨랐고 다음이 print(*ans, sep=' ')
end=' '해서 매번 출겨하는게 가장 느렸다.
print를 여러 번 할 때 병목이 있는 것으로 보인다.

Counter를 사용하는 것보다 defalutdict을 사용하는게 미묘하게 더 빨랐지만, 이정도는 무시할만 하다고 본다.

또한 이터레이터를 사용하는 것보다는 리스트를 사용하는게 약 30ms 빨랐다.
이는 게으른 계산법과 관련이 있을 것이라고 추측된다.
다만 메모리를 약 20MB정도 더 먹었다.

int로 변환하는 과정이 사라지면 200ms가 빨라졌으나, 20MB정도의 데이터를 더 먹었다.
이는 문자열이 무거운 것으로 추측된다.
또한 이터레이터+숫자보다는 리스트+문자의 Counter가 더 빠르게 동작하는 것을 볼 수 있었다.
테스트는 해보지 않았으나, 이터레이터와 Counter의 시너지가 좋지 않은 것으로 예측된다.
https://www.acmicpc.net/source/17986312 의 소스코드를 참고하여서 분석했다.

1920번
ans에 넣고 print(''.join)을 하는 것이 훨씬 빠르다.
160->124ms가 되었다.
\n을 사용하는 것은 https://www.acmicpc.net/source/17189556를 참고했다.

2869번
수학적인 문제가 제일 귀찮다. 머리가 잘 안돌아간다.

5430번
deck을 사용해서 풀었으나, deck을 사용하기 전에 operation을 통해서 index를 구하면 조금 더 빠르다.
약 10ms...?

2529번
permutation으로 해결해보았다.
permutation연산이 무거운지, 속도가 2.1s가 걸렸다. 재귀가 64ms가 걸린 것과 비교하면 천지차이이다.

15829번
나머지 연산으로 답을 낼 때, 마지막 제출 전 나머지 연산을 한 번 더 하는 것을 잊지 말자.

2839번
5로 나눠 둔 이후에 나머지마다 처리하는 것을 계산했다.
그런데 반복문으로 계산하는 것보다 느린 건 함정이였다. ;ㅅ;

1600번
처음 풀었을 때는 틀렸습니다가 되었다.
kinght와 원숭이가 움직이는 게 겹쳐서 푸는 거라 생각했는데,
반례중, 마지막이 장애물에 막혀있을 때 값이 나와야 되는 것을 보고 생각이 바뀌었다.
한 번 사용하면 값이 달라지기 때문에, 다른 정점으로 두고 풀어야 되는 문제였다.

그 다음에는
board를 deepcopy해서 값을 계산할 수 있게 만들어서 풀었다.
시간 초과가 나는 것을 볼 수 있었다. 어휴.
그래서 일단 pypy3로 푼 뒤에
https://www.acmicpc.net/source/18879368 를 참고하였다.
크게 다른 점이 없어서 deep copy를 해제하고 dist를 만들어서 풀어보았더니 6.8s정도 걸렸다.
추가적으로, if문이 많아져서 탐색에 오래 걸리는가? 라는 생각이 들어, if문을 나눴다.

아무래도 정점이 많아지다보니(최대 30만) 탐색하다가 y, x가 나왔을 때 종료하는 것이 느려진다는 생각이 들었다.
back tracking을 적용하였다. 그랬더니 최소 단위에서 오류가 났다.
처음에 backtracking을 적용하지 않았던 것이 최소 단위일 때 계산하기 귀찮아서였다.
이 부분을 처리하였더니, 5s정도 걸리는 것을 볼 수 있었다.

make_board부분에서 and로 계산할 때와 or로 계산할 때 차이가 없을 거라고 생각했는데,
예상외로 1s정도의 차이가 있는 것을 보았다.
0 <= new_y < len(board) 문법이 느린 것으로 생각된다.

# 20.05.03.
day2 jewels and stones
분명 어제 밤에는 solution이 열려있었는데, 낮에 보니 닫혔다...? 아닌가.
처음 해석이 잘못되서 이상한 짓을 하다가 다시 읽어보니 매우 간단해서 이중 for로 풀었다.
그리고 속도가 O(N+M)인 방법을 보았는데, dictionary를 써서 count하는 방법이였다.
아무래도 hash map을 사용하는 방법에 익숙해져야 될 것 같다.

4949번
처음에는 if문 4개로 구현했다가
https://www.acmicpc.net/source/14057717
를 보고 코드를 간추렸다. 아직 python에 익숙하지 않은 걸까.

if letter in '([': 을 통해서 문자가 문자열에 있는지 확인할 수 있다.
또한, stack.pop()한 것을 따로 저장하지 않고, 그대로 점검하였다.
추가적으로 검사부분이 함수로 작성된 것을 이용하여, if문을 간추렸다.
약 4ms가 빨라졌다.

1003번
어렵지 않은 dp문제였다. top_down으로 짤지, bottom_up으로 짤지 고민했는데, 좀 더 복잡한 top_down으로 쨨다.
zip을 통해서 묶어 간단하게 풀려고 했는데, index가 있어야 값을 저장할 수 있다는 점을 깨달았다.
그래서 tuple로 변환한 후, 값을 저장하게 했다.
생각해보니 index를 놓고, 값을 더해서 만드는 방법도 있었다. 흐음.

day3 ransom note
대체 왜 제목이 ransom note일까를 고민하면서 문제를 풀었는데, 내가 문제 해석을 잘못한 거였다. -_-
처음 푼 것은 magazine내에 나눠서 연속되는 ransom note를 만들 수 있는가 라고 생각했는데...
TC틀린 걸 보니 내가 해석을 잘못했다는 것을 알았다.
ransom note 만드는데, magazine내에 글자가 충분한가. 가 질문이였다. 어휴
대체 몇 분을 날린건지...

1967번
bfs와 dfs 둘 다 풀었다. post_order가 훨씬 느린게 함정.
아무래도 weights를 만들고, 이를 정렬하다보니 속도가 느려졌다.
binary tree라면 횟수가 더 적어지겠지만, binary tree가 아니라 어쩔 수 없다.
sys.setrecursionlimit(10 ** 4)로 했을 때 오류가 나는 것을 볼 수 있었다.
10 ** 6으로 하면 통과한다.
아무래도 linux기반이라 stack이 더 커서인 것 같다.
dfs도 만 번 이내라면 사용할만 할 것 같다.

# 20.05.05.
day4 number complement
자기소개서 쓰다가 까먹을 뻔 했다.
간단한 문제였다. bit연산을 할 수 있는지 묻는 문제.
num보다 큰 2의 배수를 구해 -1을 해서 전부 1로 만들고 xor를 하면 되었다.
처음에 2를 shift연산해서 망한 건 함정 + 두 번째는 index초기값 때문에 0과 1이 제대로 되지 않았다.
shift를 하면 2의 배수가 나오니.. 처음 인덱스를 잘 하도록 합시다.

# 20.05.06.
day5 first unique character in a string
defaultdict을 사용하였으나, Counter와 enumerate가 훨씬 좋은 선택이였다.

17142번
해결하는데 시간이 꽤 오래걸렸다. 바이러스가 있을 때 마지막 처리 부분이 문제였다.
3-4시간 걸려서 풀었는데, 푸는 방법은 단순했다.
바이러스를 활성화할 때 count는 증가하지만, 외부의 count는 증가시키지 않으면 되는 문제였다.
별별 짓을 다하다가 맞췄다.

# 20.05.07.
day6 majority element
Counter를 가지고 풀었는데, Boyer-Moore voting algorithm이 있었다.
majority는 항상 n/2보다 크다는 것이 보장되기 때문에 candidate를 만들고
count가 0일 경우 이번 수를 candidate에 올린다. 이후, 같으면 count를 올리고, 아니면 count를 감소시킨다.
이를 반복하면 마지막에는 개수가 n/2보다 num만 남게 된다.

1339번
permutation으로 풀어보았다.
3억번이여서 안 풀릴 것 같았는데, 예상대로 안풀렸다. python3에서는..
pypy3로는 6초가 걸린 것으로 보아 backtracking이 들어가야될 것 같았다.
다만 내 생각으로는 어렵... 일단 최대 자리수가 최대값이 들어가는 것은 맞는데..
이걸 어떻게 순열로 푸는지 모르겠다.

https://mygumi.tistory.com/156
를 참고해서 수학적방법을 추가해서 풀었다.
자리수를 계산해서 sorting하고 최대부터 값을 넣어주는 방법이다.

# 20.05.08.
day7 cousins in binary tree
처음에 node.left, right를 두고서 복잡하게 풀었는데, 답이 안나왔다.
생각해보니 본 node에 대해서 점검해야 되는 거였는데... 왜 다음 node를 점검하고 있었지. 어휴
시간이 부족해서 일단 복붙해서 던지고 천천히 해결하였다.

depth가 같은지, parent가 같은지를 판단해야 되었기 때문에 확인해야 되는 값이 두 개였다.
이를 저장하고 같은지 판단하게 만들어 주었다.

복붙했던 문제를 보니 독특했다. depth를 사용하지 않고 같은 depth만을 확인하도록 문제가 짜여 있었다.
queue에 들어가 있는 값이 전부 같은 depth에 있다는 점을 두고 queue의 len을 저장해 둔다.
이후 반복을 queue에 있는 내용만 하도록 했다.
단순하지만, 같은 depth만 보는 방법으로는 좋을 것 같다.

day8 check if it is a straight line
간단한 수학 문제였다. 1차식을 구할 수 있으냐 없느냐.
a, b를 구해서 ax + b = y를 확인하면 되었다.
x의 증가량이 0일 때 ZeroDivisionError가 났는데, 이를 try catch로 해결했다.
이것보다는.. 증가량을 구해놓고 x의 증가량이 0이면 if문을 통해 계산식을 바꾸는 것이 더 좋을 것 같았다.
float으로 계산되기 때문에 epsilon을 놓아 허용 오차범위를 두었는데,
값이 정수여서 차이가 크기 때문인지 y != ax + b로 해도 문제가 풀렸다.
흐음.. 그래도 혹시 모르니 epsilon을 두고 해결하는 게 좋을 것 같다.

11047번
증명이 중간에 뛰어서 무슨말인가를 고민했다.
https://blog.encrypted.gg/755 를 참고했다.
Ai-A1 <= Ai -1 임으로, K >= Ai이면 Ai가 포함되어야 한다.
Ai <= K < Ai+1이면
K - Ai의 최소를 구할 수 있는데, 이는 최소값에 포함된다.
따라서 그리디로 해결할 수 있다.
느리긴 하지만 DP로도 해결할 수 있다.

# 20.05.09.
카카오 2020 여름 인턴십
5문제가 나왔다.
각 문제별로 설명을 쓰긴 했으나, 올려도 되는지 알 수 없어 따로 만들었다.
문제를 풀면서 느낀건 글을 잘 읽고 풀자였다.
잘못 읽고 풀어서 망할 뻔 한게 3문제였다. 어휴.
코드와 일기는 .gitignore에 두고 올라가지 못하게 했다.

1931번
class를 만드는 김에 str과 repr를 확인하였다.
str은 사람이 이해할 수 있도록 만들어 둔 것이고,
repr은 eval같은 것으로 실행시켰을 때 실행이 가능한 문자열이여야 한다.
반환값은 str이 되어야 한다. 이를 만들면, 디버깅시 값을 확인할 수 있다.
https://itholic.github.io/python-str-repr/
https://docs.python.org/ko/3/library/functions.html#repr
https://shoark7.github.io/programming/python/difference-between-__repr__-vs-__str__

class를 구성했을 경우 attrgetter(속성명), 아닐 경우 itemgetter(index)로 key를 넘겨줄 수 있다.
또한 다중으로 정렬하기 위해서는 (1차 정렬, 2차 정렬)로 넘겨주면 다중정렬이 된다.
즉, 1차 정렬을 완성한 후, 1차정렬이 같을 경우 2차정렬을 맞춘다.
또한 정렬이 안정적임으로 같은 키를 가질 경우, 처음 정렬이 그대로 유지됨이 보장된다.
따라서
conferences.sort(key=operator.attrgetter('start'))
conferences.sort(key=operator.attrgetter('end'))
를 한 결과와
conferences.sort(key=operator.attrgetter('end', 'start'))
결과는 같다.

tuple을 정렬하면 첫번째 인덱스을 기준으로 정렬하고, 첫번째 인덱스가 같을경우 그 다음 인덱스 정렬한다.
그 다음 인덱스도 같으면 그 다다음 인덱스를 기준으로 정렬한다.
탐욕법으로 풀 때, start를 1차, end를 2차로 정렬한다.
이후 reverse로 end가 가장 뒤쪽이고 짧은 것부터 greedy정렬할 수 있다.

https://www.acmicpc.net/source/14936101
을 참고하였다.
또한, list 내포를 사용해서 read()를 저장하는 방법도 있다는 사실을 알게 되었다.

1080번
간단한 문제였다. 1931에서 배운 리스트 내포로 받아온 값을 이중 리스트 만드는 방법을 사용하였다.
추가적으로 xor연산을 통해 flip을 하였다.

https://www.acmicpc.net/source/18336351
AtoB를 미리 만들어서 점검하는 방법이 있었다.
AtoB = [[x == y for x, y in zip(arow, brow)] for arow, brow in zip(A, B)]
zip을 통해 묶어서 x, y를 미리 점검하는 것이다. 흐음. 이런 방법도 있구만.

# 20.05.10.
day9 valid perfect square
단순하게 i를 증가시키면서 square를 계산하는 방법을 사용했다.
이때 제곱은 좀 더 느리길래 i * 2 + 1로 계산하게 만들었다.

더 빠른 방법은 이분탐색이다. 이분탐색으로 점검하면서 mid를 제곱한다.

더욱 더 빠른 방법은... num ** 0.5를 하는 것이다. 내장함수는 안 썼네.. 하하

2138번
problem을 두 번 사용해야 되었기 때문에 미리 판단하는 judge라는 list를 작성하였다.
zip을 통해서 묶어서 만들었는데, 이거 생각보다 괜찮은 것 같다.
또한 min을 사용해야 되서 math.inf를 사용하였다.
조금씩 늘어가는 느낌이다.

1285번
python3로 푼 사람이 없다.
pypy3로 가장 빠르게 푼 사람을 봤는데.. 볼츠만 상수/온도 감률등 이상한 것들이 나온다.
떠오르는 건.. 물리화학적 시뮬레이션을 통해 가능한 모든 방식을 다 구현한 것 같은데 이게 어찌 빠르지..
https://www.acmicpc.net/source/19560152

값을 계속 바꿈으로, 처음에 check_board를 생성해서 True와 False를 갖는 board로 변경했다.
처음에 행을 쭉 바꾸고, sum_column으로 값을 더하도록 만들었는데, pypy3로는 약 11초가 걸렸다.
그래서 강의 답지를 보니, count를 바로 돌리는데, bitmask를 통해 값이 변경되는 행의 값을 변경하였다.
이를 적용해보니, 18초가 나오는 것을 보아, bit shift연산이 반복되다보니 느려지는 점이 있는 것 같았다.

https://www.acmicpc.net/source/18327076를 참고하여 letter를 두고 이 값을 변경시키는 방법을 사용했다.
9.9초정도로 감소하는 것을 볼 수 있었다.
추가적으로 True와 False를 count에 계속 더하는 연산에 형변환이 부담될 수 있을 것 같아, if문으로 변경하였다.
=> 약 300ms가 빨라졌다.
혹시 min함수와 관계가 있을 가능성이 있어, min함수를 제거하였다.
=> 800ms가 빨라졌다.

x와 y를 바꿔서 bit연산을 더 빠르게 할 수 있을 것 같았으나...
생각해보니 x와 y가 바뀌면 x에 대해서 쭉 더하는 것이 아니라 틀리게 된다.
y에서 bit연산을 계속(총 400번)하는 것이 문제니, 미리 계산하면 어떨까라는 생각이 들었다.

약 1초 더 느려지는 것을 볼 수 있었다. 신기하구만.
bit연산이 메모리 접근보다 빠른가보다.

가장 빠르게 푼 건 어떻게 풀었는지 보자.
https://justicehui.github.io/koi/2019/09/19/BOJ2582/
https://koosaga.com/3
휴리스틱 서치로 모의 담금질 기법을 사용한다고 한다. ....?!

# 20.05.11.
day10 find the town judge
수학적으로 간단하게 풀 수 있을 것 같았으나, 귀찮아서 dictionary에 때려박았다.
그리고 답지를 보니, 확실히 쉬운 방법이 있었다. 어휴.
단순하게 counter를 두고 답을 더하고 빼고 하면 간단하게 답이 나온다.

1202번
처음 만들었을 때 sort를 복잡하게 weight가 같으면 bag까지 확인하도록 했다.
python3로는 속도가 느려서 안되었고, pypy3로 4초가 걸렸다.
간단하게 sorting할 수 있도록 sorting을 두 번 했다. sort는 정렬 안정성이 보장되니.
그 결과 pypy3로 3.8s, python으로 4.6s가 걸렸다.
혹시 __lt__로 만들어 둔 부분이 느리게 반응하나 싶어, key=를 통해서 정렬을 시도했다.
3.2s까지 빨라졌다.
bag_count를 두어서 bag가 끝났을 때를 반환하도록 만들었을 때 2.9s까지 빨라졌다.
sort에 key값을 두고 계산하기 때문에 def __lt__가 필요없을 거라 생각해서 지웠는데, 지우면 오류가 난다.
왜지...?

max_heap과 관련된 자료이다.
https://python.flowdas.com/library/heapq.html
https://claude-u.tistory.com/152
https://www.daleseo.com/python-heapq/
https://medium.com/@yhmin84/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-priority-queue-%EB%A5%BC-%EC%9C%84%ED%95%9C-heapq-%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9%EB%B2%95-b33c4e0ef2b1

우선순위 큐
https://dongchans.github.io/2019/29/

# 20.05.12.
1202번
좀 더 빠르게 돌려보았다.
https://www.acmicpc.net/source/19539661 참고했다.
이를 보고 처음에는 for로 했는데, index를 고려하기 힘들어 while을 통해 index를 바꾸도록 변경했다.
계속 런타임이 떠서 고민했는데, heap에서 출력하는 부분이 문제였다.
heap이 있는지 없는지 확인하지 않아서, 없는데도 pop해버리니 런타임 에러가...
에러잡는데 시간이 꽤 걸렸다.
참고한 소스를 더 참고해서 풀면 빠를 것 같았으나.. 완전히 똑같게 풀어서 포기했다.
이런 문제는 while을 쓰는게 더 편하다.
BST로 푸는건 제작해야 되는게 많아서 포기했다. 나중에 시간되면 풀어보도록 하겠다.

2109번
대충 읽고 알고리즘 짜다가 망할 뻔 했다.
1, 2, 3까지 갈 수 있는 것이라 생각해서 각각에 대해서 최대 값을 구하는 알고리즘이라 생각했는데,
3이 여러 개 있더라도 2일 일때 3일까지 가도 되는 것이였다. 이내로 오면 되기 때문에.
글을 잘 읽자는 생각이 무럭무럭 든다.

# 20.05.13.
14888번
역시 순열보다는 재귀가 빠르다.
더 빠른 사람들을 보니, 바깥에 max와 min의 값을 넣어둬서 zip과 같은 쓸 때 없는 연산이 없다.
함수로 묶어두었으니... 알고리즘 문제 풀이에서 적당한 전역변수가 좋다고 하는 이유가 재귀 때문인 것 같다.

순열을 간만에 만들었더니 오류가 많다. 헷갈리기도 하고
순서를 다시 보면, 뒤쪽부터 탐색하여 마지막 순열의 위치를 확인한다.
-1까지 탐색을 했는데.. python이라 오류가 없었다 ㄷㄷ
그 후, 마지막 순열 앞의 숫자보다 크지만, 가장 작은 숫자를 찾는다.
이를 바꿔주고, 마지막 순열을 뒤집어준다.
생각보다 구현하면 오류가 많다.

일반적인 permutation으로 하면 중복이 제거되지 않음으로, 구현해야 되는 경우가 좀 있다.
쩝...

day12 single element in a sorted array
뭔가 sum으로 계산하는 방법이 있었던 것 같은데.. 하면서 기억이 안났다.
set(nums)를 한 뒤 값을 다 더하고 *2를 한다. 이러면 모든 값이 2배가 된다.
이후 nums를 빼주면 해결.

선형방법이긴 하나, for문을 통해서도 해결할 수 있다.index와 index+1의 값이 다르면 된다.

아직 이분탐색을 잘하지 못하는 것 같다.
simple single non duplicate를 보면 훨씬 간단한 것을 볼 수 있다.
return값이 항상 left에서 나오도록 만들어져있다.
이로 인해 left < right를 사용해서 1개의 값이 들어와도 문제가 없게 설정되어 있다.
right를 mid -2로 하도록 했는데, 이는 left도 right도 아니면 mid가 답이기 때문이다.
하지만 right = mid로 하면 탐색을 몇 번 더하지만, right부분에 값이 걸리기 때문에 만들어지는게 간단하다.
또한 홀수인지 확인하는 방법을 bit연산자로 처리하는 것을 보니.. 역시 나는 아직 부족하다.

1790번
이분탐색을 시작했다.
아직까지는 익숙하지 않아서 그런지 오류가 많다. 하다보면 늘겠지.
left, right 잡는 게 아직 어색하다. leet code에서도 연습 했었는데 흐음.

1654번
right부분으로 갈수록 숫자가 작아진다.
따라서 같은 지점을 찾기 위해서는 right가 mid - 1이 되어야 한다.
mid의 값이 need_num을 포함하지 않는다면 왼쪽에 답이 있다.
따라서 right가 mid -1이 되어야 한다.
만약에 left를 mid + 1로 할 경우에는 11의 범위 중 처음 만난 왼쪽 범위로 수렴한다.
need_num <= 이 되어야 왼쪽이 점점 오른쪽으로 이동하게 된다.
이 때, mid부분의 //2 연산은 항상 왼쪽에 붙기 때문에, 오른쪽으로 붙을 수 있도록 +1을 해준다.

# 20.05.14.
day13 remove k digits
처음에는 index로 접근했는데.. 만들다가 stack로 만들면 편하지 않을까 했다.
그래도 계속 진행했으나 틀림. stack으로 바꾸었어야 되었다.
검색해가다가 앞쪽 수가 클 경우 제거함으로서 앞쪽에 큰 수가 나오는 것을 막는다.
이 때 앞쪽의 큰 수를 while을 통해서 계속해서 없애주어야 되었는데,
index로 구성할 때는 불가능했었다. 그래서 마지막에 다시 돌려주도록 만들었으나, 오류가 났다.
stack으로 구성된 것을 보니 훨씬 이해하기 쉽고, 내 알고리즘이 어디서 틀렸는지 알게 되었다.

lstrip을 왜 쓸까 고민했는데, 활용 방법을 여기서 보았다.
왼쪽에 필요없는 문자가 있을 경우 지워주기...

2805번
위에서 아래로 내려오니 right를 줄여가면서 계산한다.
속도가 꽤 느려서 다른 사람의 답을 보았다.
bianary부분의 문제인가 했는데, 아무래도 100만개를 자르다보니 100만개 계산이 느린 것 같았다.
max로 불러드리는게 느릴 것 같아서 MAX를 주고 시작했는데,
생각해보니 100만개를 잘라보는게 1번 늘어나는 것 보다는 max로 계산하는게 편할 것 같아 max를 주었다.

https://www.acmicpc.net/source/18949565를 참고하여 자르는 것을 빠르게 하기 위해 Counter를 사용했다.
같은 길이의 나무가 있으면 한 번에 자르는게 훨씬 빠르니.
3000s에서 500s로 줄었다.

2110번
이해가 잘 안되는 문제였다.
https://mygumi.tistory.com/301 도 참고해서 이해했다.
공유기를 설치하는데, 가장 가까운 공유기 2개 거리의 최대값을 구하고 싶다.는게 문제이다.
따라서 k라고 거리를 둔 뒤, k보다 가까우면 설치하지 않고, k보다 멀거나 같으면 설치한다.
이렇게 설치한 공유기 댓수와 설치하고 싶은 공유기 댓수를 비교한다.
만약에 k라고 둔 뒤 설치했을 때, k-1이면 공유기 댓수보다 작고, k일 때 클 수 있다.
이 때, 공유기 댓수가 클 경우가 답이 된다.
가장 가까운 거리가 k였음으로, k이외에 다른 공유기를 빼면 된다.

1939번
binary로 풀었다. 문제가 없어보이는데 시간초과가 나서 소스를 보았다.
차이가 없다. mid를 ans로 두는 점?
이 부분이 한 번 정도 덜하게 만드나 싶어 바꾸려고 했다.
바꾸면서 보니 left < weight로 적어서 엄청나게 느린 거였다.
값을 변경하니 제대로 답이 나온다.

이전에 카카오에서 푼 것과 유사하게 bfs로 풀어볼려고 했다.
중간에 시간초과가 난다.
생각해보니 카카오는 전후좌우임으로 4개만 고려하고, 돌아오는 것도 그리 많지 않았지만,
이 그래프는 여러 간선으로 연결되니 점검하는 과정이 너무 많아서 그런 것 같다.


# 20.05.15.
day14 implement trie (prefix tree)
시간이 부족하여 아래를 참고했다.
https://leetcode.com/problems/implement-trie-prefix-tree/discuss/632380/PYTHON-Faster-than-97.69-TRIE-with-nested-dictionary-Prefix-Tree
처음보는 자료구조였다. 어떻게 풀지 아예 감도 없는 자료구조.
Trie라고 하는 자료구조가 따로 있었다.
solution과 https://twpower.github.io/187-trie-concept-and-basic-problem을 참고했다.
독특한 자료구조이다. 용량을 우걱우걱 먹어서 속도를 올리는 방법.
사용하는 곳은 자동완성, 맞춤법 검사, ip routing 등 시작부터 얼마나 맞는지 확인할 때 사용한다.
dictionary와 array가 있는데, 보고 구성한 것은 dictionary였고, 직접 만든건 array였다.
단어가 적어서 그런가, dictionary보다는 array가 훨씬 용량을 많이 먹고, 속도도 느렸다.

구성은 다음과 같다.
넣는 것은 문자가 있어 다음노드가 있는지 확인하고 없으면 새로 만들어서 다음 노드를 넣는다.
문자를 계속 반복해서 넣게 된다.
마지막에는 end문자열을 넣어, 이게 마지막임을 알린다.

검색은 문자가 있는지 확인하면서 없으면 False를 반환한다.
마지막에 가서 is_end가 있는지 확인하고 없으면 False이다.

prefix검색은 문자가 있는지 검색하면서 마지막까지 가면 True를 반환해준다.

2022번
문제가 잘 이해가지 않았다.
방정식이고 d를 제외한 모든 값이 주어졌으니 d를 풀 수 있을 것 같았다.
그런데, d로 방정식을 푸는게 너무 어려운가 보다. 다들 수치해석을 했다.
그리고 식을 간단하게 할 때는 h1, h2로 미지수를 놓는것이 편하다.
d로 정리해서 한 번에 풀 생각이 아니라면 말이다.
https://sw-ko.tistory.com/145
http://joonas-yoon.blogspot.com/2016/11/2022-crossed-ladder.html
를 참고했다.

2573번
다른 사람것을 참고했으나, 다른 지점을 못찾겠다. 그런데 속도가 약 3/4정도 느리다. 흐음.
신기하게 if count > 2인 부분을 내부에서 확인하든 확인하지 않든 속도가 같다.
가장 느린 것이 아마 다 줄어들어 0이 될 때인가 보다.

# 20.05.16.
day15 maximum sum circular subarray
자고 일어났더니 제출시간이라 복붙했다.
접근 방식을 보니 1, 2번은 내가 접근했던 방식이랑 유사하다. 실패하긴 했지만.
dp로 max_sum을 구하는 방식인데, 이 방식에는 Kadane's Algorithm이라는 이름이 붙어있다.
다만, dp-array를 쓰지 않고 해결할 수 있었다.
cur이라는 변수를 두어, 이번의 값과 max(cur, 0)을 통해 cur이 -로 떨어졌으면 0으로 변경해준다.
그리고 ans = max(ans, cur)을 하여 ans에 최대값을 더해준다.

solution의 설명이 좋지 않았나보다. solution 밑에 성토가 넘쳐난다.
solution을 제대로 이해하지 못해서 복붙한 것을 보았다.
이를 통해 solution을 대충 이해할 수 있었다.

한번 max_sum을 구하고, 그 후 돌아가는 것을 통해 2번째로 max_sum을 구해야한다.
이를 뒤집어보면, total 합을 구하고, total에서 sum_min을 빼면 2번째로 돌아가는 방향이라고 볼 수 있다.
최대로 떨어지는 sum_min을 구하면 이 부분을 제거해서 두 번째로 돌아가는 부분의 최대를 구할 수 있다.

1 2 -8 2 5 -8 5 6 이 있으면
최대로 떨어지는 부분은 -8 ~ -8까지로 -9가 나온다.
2번째로 돌아가는 부분은 5 6 1 2가 최대이다.
이를 구하는 것이 total - min_sum이 되게 된다. (전체에서 가장 작은 sum을 빼는게 최대)
max_sum과 이를 비교하게 되면 첫 번째 max_sum과 두 번째 max_sum을 구하게 되는 것이다.
이 때, > 0 큰지 확인하는데, 값이 전부 음수일 경우에는 가장 음수인 것이 최대임으로 max_sum을 반환한다.

이거 이해하는데 하루를 다 소모했다.

11664번
처음 풀어보는 삼분탐색이다. 어떻게 구하는지 감이 정말 안 왔다.
우선 좌표를 일일히 구하는 것이 아니라, left와 right를 0, 1.0으로 두어 비례값으로 계산한다.
이 때 실수한 부분이 mid1과 mid2를 구하는 것이였는데, 이분탐색과 달랐다.
단순하게 더해서 반으로 나누면 나오는 이분탐색과 달리 1/3을 구해서 더하고 빼줘야 된다.
이 부분을 생각하지 않고 이분탐색처럼 풀었더니 값이 수렴하지 않았다.
처음 푸니 어려운 것 같다.

# 20.05.17.
2343번
간단한 이분탐색 문제였으나, 중간에 혼동이 있어서 망했다.
처음에 left가 아닌 right에서 -1을 하도록 하였다.
그랬더니 값이 left에 모여서 +1을 해주어야 했다.
틀렸습니다가 나와서 곰곰히 생각해보니. count가 클 경우에는 mid에는 닶이 없는 것이다.
따라서 left = mid + 1이 되어야 된다.

최소값을 처음에 min(lesson_lengths)로 두었으나, 생각해보니 max가 되어야 되었다.
0으로 놔도 크게 문제는 없다.

최대값을 MAX (10**9)로 설정했으나, 실제 최대값은 sum(lesson_lengths)였다.
https://www.acmicpc.net/source/19245920
를 참고하였다. 30ms정도 빨라졌다.

day16 odd even linked list
생각했던 것보다 수월하게 해결했다. prev와 next를 두고 순환하게 했다.
머리 속에 잘 그려지지 않아서 직접 debugging하면서 푼게 유효했다.

다만 솔류션을 보니 next와 prev를 사용하지 않고, odd, even 두 가지만으로 해결할 수 있었다.
그런데 이 속도가 훨씬 느리다. 흐음.

처음으로 list에서 linked list를 만드는 함수를 짰다.
잘 돌아가서 다행인데, str에 self.next를 넣어두니, 신기하게 그 다음것을 찾고, 또 다음 것을 찾았다.
재귀가 자동으로 되는 것 같았다.
아마 next에 대한 __str__을 호출하기 때문인 것으로 추측한다.

12015번
생각보다 간단한 문제였다.
dp로 풀기에는 양이 너무 커서 풀 수 없는 문제이다.
O(n^2)으로는 너무 크니..

https://www.acmicpc.net/source/1834172 참고하여 알고리즘을 약간 변경했다.
처음에는 find_index에서 마지막이 큰지 확인하는 연산이 들어갔다.
right와 number를 점검해서 크면 len을 반환하고, append하는 것이였다.
점검 전에 맨 마지막이 큰지 먼저 확인하면 index에 대한 복잡한 계산이 사라진다.
좀 더 함수가 간단해지면서 700ms가 빨라졌다.

직접 만든 binary search보다 bisect라는 함수를 쓰는 것이 훨씬 빠르다.
2.1s에서 772ms로 감소하는 것을 볼 수 있다.
아마 C로 짜있는 함수여서 빠른 것으로 파악된다.

bisect 모듈에 대해서는 https://lioliolio.github.io/python-bisect-module/ 를 참고한다.

1182번
전부 선택 안할 때를 고려해야 되었으나, 귀찮았다.
expect == 0이면 count -1을 하는 것으로 간단하게 해결했다.

14225번
재귀로 푸는건 간단하다.
이게 그리디로 풀 수 있다고 하나, 이해하기가 어렵다.
다음에 풀어보도록 하자.

# 20.05.18.
15658번
14888번에서 숫자가 늘어났을 뿐이다.
이전에 푼 것을 그대로 사용해도 되지만, 며칠 지났다고 잘 기억이 안나길래 구현해봤다.
뭔가 이전보다 구현이 잘 된 느낌이다.
calc로 묶어서 다 계산하지 않고, 미리 계산해 놓은 뒤에 움직였더니 훨씬 깔끔해졌다.
그땐 왜 zip으로 풀었지 흐음..
속도가 빠른 걸 보았더니 if문을 일일히 썼다.
https://www.acmicpc.net/source/16885807 참고하면 hardcoding이 빠를수도 있겠다는 생각이 든다.

16197번
약간 복잡하긴 했지만, 각 예외를 두어 backtracking 후, recursion으로 해결하였다.
60ms로 풀 수 있던데, bfs로 풀이한 거였다.
잠깐 고민해봤는데, 아직 풀 수 있는 방법이 떠오르지 않았다.
방향을 고려해야 되는데, 가능한가...
tracking해서 확인해야 될 것 같긴 하다.

# 20.05.19.
16198번
set이나 linked list등을 고려했으나, set은 불가능하고, 이중 linked list는 구현하기 귀찮았다.
index_list같은 것도 고려해쓴데, 어쩌피 찾아야 되니, 그냥 pop. insert연산을 했다.
어쩌피 list가 10개이다.
https://www.acmicpc.net/source/17793412를 참고 하였을 때, list덧셈연산으로 구현한게 있었다.
4ms빨라지는 걸로 봐서 크게 차이 없는 것 같다.

1600번
누군가 짜증나는 소리를 해서 pypy3와 c간의 차이를 보기 위해 잠깐 검색했다.
신선한 부분을 볼 수 있었는데, pypy3에서는 deepcopy가 매우 빠른 것으로 보인다.
python3에서 deepcopy를 사용하면 시간초과가 나서 변경해서 풀었는데,
이것이 역으로 pypy3로 가면 속도가 거의 2배 느려진다.
pypy3는 deepcopy를 사용하는게 더 빠른가보다.

14502번
누군가 파이썬 느려서 안되는 겁니다. 빼액 하길래 풀어보았다.
간단하게 풀어도 3초 이내로 푸는데...?!
속도가 느린 이유는 벽을 세울 때 itertools.combination을 쓰기 때문이 아닐까 싶었다.
그래서 재귀를 구현하였으나, 속도차이가 없었다. 어휴.

제너레이터를 구현해보았는데, yield가 있으면 재귀가 성립하지 않았다.
아마 문법 내에 yield가 있는 것을 보고 함수 호출을 중단하는 듯 했다.

위치 확인을 or로 고쳐서 120ms정도 빨라졌다.
그리고 방의 개수를 다시 확인 하는 것을 고쳐, 값을 빼도록 만들었더니 70ms가 빨라졌다.

이제 차이가 있는 건 dfs인 것 같은데.. dfs를 구현하긴 귀찮으니 넘기도록 하자.

9663번
3차원 배열을 통해서 True를 놓긴 했는데.. 더 좋은 방법이 있을 것 같다.
그건그렇고 계속 답이 이상하게 나와서 debugging을 열심히 했는데, 문제는 2를 쓸껄 True를 적어놨었다.
어휴.
더 빠른 방법은 강의를 듣고 생각해보자.

1541번
방법은 같았으나, 간단하고 이해하기 쉬운 방법이 있었다. 너무 복잡하게 생각했다.
-를 기준으로 나눠주고, +를 기준으로 다시 나눠줘서 더하면 되었는데...
https://www.acmicpc.net/source/18197192
를 참고해서 간단하게 풀어보았다.

아무래도 input이 작다보니 리스트 내포가 느린 것 같다.
52ms나던게 88ms가 나는 것은 뭔가 이상한데.

1744번
최소힙, 최대합으로 간단하게 풀었다.
sort를 하는 것과 heap을 사용하는게 속도가 비슷해서 슬프긴 하다.
0까지는 쉽게 생각했는데, 1이 있는 건 고려하지 못했다.
2*1을 더해주는 것보다는 2 + 1이 더 큰데.
다 구해놓고 하나 못하는 건.. ;ㅅ;

# 20.05.20.
2875번
단순한 수학문제 같은데 greedy인가..?
하긴 다 따져보지 않고 간단하게 풀었으니 greedy로 볼 수도 있을 것 같다.

10610번
이것도 단순한 수학문제였다.
다만, int로 바꿔서 %3을 나누고 str로 다시 변환하는 작업의 시간이 꽤 걸리는 것 같다.
이를 미리 sorting해서 사용하니 식도 간단해지고, 속도도 빨라졌다.
272s -> 88ms가 되는 걸 보면 흐음..

12970번
단순하게 그리디로 해결하였다.
사람이 계산하기는 처음에 A를 전부 채운 후 뒤쪽부터 B를 채워 나가면서 그 앞에 A가 몇 개있는지 보는게 쉬웠다.
컴퓨터는 앞에서부터 세니, 앞부터 세도록 고쳤다.
단순하다. 전부 B로 채운다. 그리고 맨 앞에서부터 'A'를 채울지 말지 결정한다.
맨 앞에 A를 넣는 것이 쌍을 가장 크게 만드는 방법이다.
따라서 우리가 필요한 쌍의 개수보다 현재 계산한 쌍이 적으면 무조건 채운다.

A를 채웠을 때 늘어나는 쌍의 개수는 앞에 있는 B의 개수와 같다.
-맨 마지막부터 채우기 때문에 B의 개수는 항상 고정이다.
그런데 앞쪽에 채워진 a는 B가 A로 바뀌기 때문에 앞의 A의 개수만큼 줄어들게 된다.
따라서 지금까지 계산한 쌍의 개수에 A를 채우는 앞쪽의 B의 개수를 더하고, 앞에 있는 A의 개수를 뺀다.
이게 이번에 A를 채울 때 만들어지는 쌍이 된다.

복잡해보이지만, 규칙을 찾으면 O(n)으로 해결할 수 있는 문제였다.

12904번
답에서 처음으로 돌아가는 greedy 문제였다.
reverse를 계속하면 느릴 것 같아 two pointer로 해결하였다.
신기한 점이 있다면, reverse하는 함수가 있을 것 같아서 reverse라고 치고 tap을 누르니 나왔다.
항상 sorting만해서 reversed를 하도 안 썼더니 까먹었다.
파이썬은 항상 신기하단 말이지...

1783번
분명 브론즈 1인데 다른 문제보다 훨씬 어렵게 느껴졌다.
아무래도 문제를 분할해서 푸는 연습이 안되어 있어서 그런 것 같다.
오른쪽으로만 간다는 생각은 했으나, 이를 어떻게 생각할지를 잘 고민하지 않았다.
pdf를 보고 해결했다.

아무래도 조건 중 4번이상 가면 꼭 다른 것을 사용해야된다는 조건을 보고 멍 때린게 문제였나보다.
무조건 짧은 것을 쓰고, 긴 건 안 쓴다는 생각으로 접근했으면 금방 풀 수 있는 문제였다.
어휴...

10773번
stack을 사용하는 간단한 문제였는데, 속도가 생각보다 느려서 잠깐 생각했다.
다른 사람의 답을 보니 number > 0대신 number == 0을 썼길래 확인해보았다.
결론: 차이가 없다.
만들어지는 거 생각해보면 다를 이유가 없긴 하다.
받아드리는 시간이 있어서 좀 느린가보다.

@@@
1476 중국인의 나머지 정리로 해결해보기
6064 중국인의 나머지 정리로 해결해보기
1107 자리수 비교를 통한 문제풀이. -너비우선탐색, 그래프이론, 그래프 탐색
16197 bfs풀이?

14225 greedy풀이해보기
# https://www.acmicpc.net/source/17918992
# https://peanut2016.tistory.com/225

15661 python3로 돌아가게 변경해보기
1285 python3로 돌아가게 변경해보기
- Simulated annealing을 사용
참고자료
https://justicehui.github.io/koi/2019/09/19/BOJ2582/
https://zzsza.github.io/data/2019/04/01/simulated-annealing/
https://koosaga.com/3
https://dlucky.tistory.com/36

14500 재귀..? 왜?

1202 BST로 풀어보기
5052 trie연습해보기

1424 failed
17619 failed
400 도전 문제 해결하기

CodeJam
parenting partnering returns
indicium

-- 진도
531 스도쿠부터
821 이분탐색 구간나누기부터
그리디 연습 듣기
분할정복-정렬 듣기