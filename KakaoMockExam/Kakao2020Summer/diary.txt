# 20.05.09.
2020 카카오 문제 1
처음 글을 잘못 읽고 풀다가 중간에 이상한 점을 눈치채고 나중에 풀었다.
왜 이런 미친 짓을 했을까...
단순한 문제였다. 숫자 위치를 만들어 주고, 설명에 따라 어느 위치를 가지는지 확인해주면 되는 문제였다.

카카오 코딩테스트 문제 2
연산자 우선순위를 만들어서 계산하는 문제였다.
이전에 풀어보았던 stack으로 후위 연산하는 방법으로 풀었다.
연산자 순위 가지수는 6개임으로 brute force를 했다.
중위로 나타나 있어서 이를 어떻게 후위로 집어넣나를 고민했는데, index를 넘어가면서 계산하게 했다.

2020 카카오 문제 3
실패한 문제이다. 간단하게 two pointer를 두고 greedy로 풀 수 있을거라 생각했는데 풀 수 없었다.
계산상은 맞을 것 같은데 왜 안 나오는지는 잘 모르겠다.
총 gem을 가지고 있는 having_gem dictionary를 만들었다.
총 보석의 가짓수를 가져온다.
이후 처음 candidate(위치 후보)는 index 0부터 마지막까지로 정해준다.
gem의 index를 증가하면서 gem을 추가하고, index를 반환했다.
이후 이전 pointer를 이동하면서 점검하였다.

풀이를 쓰면서 보니 왜 틀렸는지 알았다. 확인하는 순서가 잘못되었다.
having_gem에 1을 더한 후, 이전 pointer를 이동시킨 뒤, kind_num과 == current_num을 확인해야 되었다.
그래야 최소 index가 나올 수 있다.
어휴...

2020 카카오 문제 4
변형된 bfs문제였다. 정확하게는 backtracking의 느낌이다.
처음에 문제를 잘 읽었어야 되었는데, 대충 읽었다가 망할 뻔했다.
다음 칸으로 가면 100원, 꺽어서 다음칸을 가면 600원이 추가되어야 한다.
그래서 board에 최소값을 입력하는데, board칸에 최소로 간다고 보장할 수 없었다.
그래서 다음 값이 같거나 작으면 queue에 넣고 계속 가게 만들었다.
그리고 답이 틀리길래 왜 틀리는거야... 라고 생각했는데, DYX를 잘못만들었다.
오른쪽, 위, 왼쪽, 아래쪽으로 index를 두었는데,
만든 것이 오른쪽 아래, 왼쪽 오른쪽으로 값이 들어갔다.
y가 증가하는 방향이 아래였다.
생각해보니 그동안 그거 고려 안하고 풀었는데, 이번에는 고려해야 되는 문제여서 망한 거다.

2020 카카오 문제 5
유사한 문제를 푼 기억이 있어서 해결했다. -백준 9328번 열쇠
먼저 가야되는 지역이 열쇠이고, 이후 들려야 되는 지역을 잠긴 문으로 보았다.
잠긴 문은 방문하긴 하나, 열쇠가 없다면 방문만 하도록 했다.
그리고 열쇠로 열었을 때, 방문이 되어있다면 queue에 넣고, 아닐 때는 잠겨있지 않도록만 표시하도록 했다.
잠긴 문을 방문하는 것이 상관 없는 이유는 key에 접근 했다면 자동으로 다시 방문할 것이고,
키에 접근하지 못했다면 잠긴 문에 방문했더라도 어쩌피 key에 접근 못해서 실패했을 것이다.
이렇게 접근한 이유는 문에 들리지 않았는데, 열었다고 시작하면 문제가 발생하기 때문이였다.

처음 제출했을 때 2-3개가 틀려서 왜 틀렸나 고민했는데,
다시 천천히 보니 key=0일때 문을 여는 동작을 하지 않았다.
천천히 다시 훑어보니 무엇이 문제였는지 알 수 있었다.
